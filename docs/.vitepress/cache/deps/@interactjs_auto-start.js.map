{
  "version": 3,
  "sources": ["../../../../node_modules/@interactjs/auto-start/InteractableMethods.ts", "../../../../node_modules/@interactjs/auto-start/base.ts", "../../../../node_modules/@interactjs/auto-start/dragAxis.ts", "../../../../node_modules/@interactjs/auto-start/hold.ts", "../../../../node_modules/@interactjs/auto-start/plugin.ts", "../../../../node_modules/@interactjs/auto-start/index.ts"],
  "sourcesContent": ["import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { ActionProps, PointerType, PointerEventType, Element } from '@interactjs/core/types'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    getAction: (\n      this: Interactable,\n      pointer: PointerType,\n      event: PointerEventType,\n      interaction: Interaction,\n      element: Element,\n    ) => ActionProps | null\n    styleCursor: typeof styleCursor\n    actionChecker: typeof actionChecker\n    ignoreFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n    allowFrom: {\n      (...args: any[]): Interactable\n      (): boolean\n    }\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n  } = scope\n\n  Interactable.prototype.getAction = function getAction (\n    this: Interactable,\n    pointer: PointerType,\n    event: PointerEventType,\n    interaction: Interaction,\n    element: Element,\n  ): ActionProps {\n    const action = defaultActionChecker(this, event, interaction, element, scope)\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction)\n    }\n\n    return action\n  }\n\n  /**\n   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n   * of it's parents match the given CSS selector or Element, no\n   * drag/resize/gesture is started.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `ignoreFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .draggable({\n   *     ignoreFrom: 'input, textarea, a[href]'',\n   *   })\n   *   .pointerEvents({\n   *     ignoreFrom: '[no-pointer]',\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to not ignore any elements\n   * @return {string | Element | object} The current ignoreFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('ignoreFrom', newValue)\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\n\n  /**\n   *\n   * A drag/resize/gesture is started only If the target of the `mousedown`,\n   * `pointerdown` or `touchstart` event or any of it's parents match the given\n   * CSS selector or Element.\n   *\n   * @deprecated\n   * Don't use this method. Instead set the `allowFrom` option for each action\n   * or for `pointerEvents`\n   *\n   * ```js\n   * interact(targett)\n   *   .resizable({\n   *     allowFrom: '.resize-handle',\n   *   .pointerEvents({\n   *     allowFrom: '.handle',,\n   *   })\n   * ```\n   *\n   * @param {string | Element | null} [newValue] a CSS selector string, an\n   * Element or `null` to allow from any element\n   * @return {string | Element | object} The current allowFrom value or this\n   * Interactable\n   */\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('allowFrom', newValue)\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\n\n  /**\n   * ```js\n   * interact('.resize-drag')\n   *   .resizable(true)\n   *   .draggable(true)\n   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n   *\n   *     if (interact.matchesSelector(event.target, '.drag-handle')) {\n   *       // force drag with handle target\n   *       action.name = drag\n   *     }\n   *     else {\n   *       // resize from the top and right edges\n   *       action.name  = 'resize'\n   *       action.edges = { top: true, right: true }\n   *     }\n   *\n   *     return action\n   * })\n   * ```\n   *\n   * Returns or sets the function used to check action to be performed on\n   * pointerDown\n   *\n   * @param {function | null} [checker] A function which takes a pointer event,\n   * defaultAction string, interactable, element and interaction as parameters\n   * and returns an object with name property 'drag' 'resize' or 'gesture' and\n   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n   * props.\n   * @return {Function | Interactable} The checker function or this Interactable\n   */\n  Interactable.prototype.actionChecker = actionChecker\n\n  /**\n   * Returns or sets whether the the cursor should be changed depending on the\n   * action that would be performed if the mouse were pressed and dragged.\n   *\n   * @param {boolean} [newValue]\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.styleCursor = styleCursor\n}\n\nfunction defaultActionChecker (\n  interactable: Interactable,\n  event: PointerEventType,\n  interaction: Interaction,\n  element: Element,\n  scope: Scope,\n) {\n  const rect = interactable.getRect(element)\n  const buttons =\n    (event as MouseEvent).buttons ||\n    {\n      0: 1,\n      1: 4,\n      3: 8,\n      4: 16,\n    }[(event as MouseEvent).button as 0 | 1 | 3 | 4]\n  const arg = {\n    action: null,\n    interactable,\n    interaction,\n    element,\n    rect,\n    buttons,\n  }\n\n  scope.fire('auto-start:check', arg)\n\n  return arg.action\n}\n\nfunction styleCursor(this: Interactable): boolean\nfunction styleCursor(this: Interactable, newValue: boolean): typeof this\nfunction styleCursor (this: Interactable, newValue?: boolean) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue\n\n    return this\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor\n\n    return this\n  }\n\n  return this.options.styleCursor\n}\n\nfunction actionChecker (this: Interactable, checker: any) {\n  if (is.func(checker)) {\n    this.options.actionChecker = checker\n\n    return this\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker\n\n    return this\n  }\n\n  return this.options.actionChecker\n}\n\nexport default {\n  id: 'auto-start/interactableMethods',\n  install,\n}\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type {\n  CursorChecker,\n  PointerType,\n  PointerEventType,\n  Element,\n  ActionName,\n  ActionProps,\n} from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\n\nimport InteractableMethods from './InteractableMethods'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Omit<SignalArgs['interactions:move'], 'interaction'> & {\n      interaction: Interaction<ActionName>\n    }\n    'autoStart:prepared': { interaction: Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Element\n    ignoreFrom?: string | Element\n    cursorChecker?: CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    // TODO: docst\n    mouseButtons?: 0 | 1 | 2 | 4 | 8 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interactable\n  interaction: Interaction\n  element: Element\n  action: ActionProps<ActionName>\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Element\n}\n\nfunction install (scope: Scope) {\n  const { interactStatic: interact, defaults } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom: null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  /**\n   * Returns or sets the maximum number of concurrent interactions allowed.  By\n   * default only 1 interaction is allowed at a time (for backwards\n   * compatibility). To allow multiple interactions on the same Interactables and\n   * elements, you need to enable it in the draggable, resizable and gesturable\n   * `'max'` and `'maxPerElement'` options.\n   *\n   * @alias module:interact.maxInteractions\n   *\n   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n   */\n  interact.maxInteractions = (newValue: number) => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  if (interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove (\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:move'],\n  scope: Scope,\n) {\n  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove (arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction } = arg\n\n  if (\n    !interaction.pointerIsDown ||\n    interaction.interacting() ||\n    !interaction.pointerWasMoved ||\n    !interaction.prepared.name\n  ) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = (interaction as Interaction<ActionName>).prepared.name\n\n  if (actionName && interactable) {\n    // check manualStart and interaction limit\n    if (\n      interactable.options[actionName].manualStart ||\n      !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)\n    ) {\n      interaction.stop()\n    } else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop ({ interaction }: { interaction: Interaction }, scope: Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction<T extends ActionName> (\n  action: ActionProps<T>,\n  interactable: Interactable,\n  element: Element,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  if (\n    interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n    interactable.options[action.name].enabled &&\n    withinInteractionLimit(interactable, element, action, scope)\n  ) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches (\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  matches: Interactable[],\n  matchElements: Element[],\n  eventTarget: Node,\n  scope: Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) {\n      continue\n    }\n\n    const action = validateAction<ActionName>(matchAction, match, matchElement, eventTarget, scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo (\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  let matches: Interactable[] = []\n  let matchElements: Element[] = []\n\n  let element = eventTarget as Element\n\n  function pushMatches (interactable: Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(\n      interaction,\n      pointer,\n      event,\n      matches,\n      matchElements,\n      eventTarget,\n      scope,\n    )\n\n    if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = domUtils.parentNode(element) as Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare (\n  interaction: Interaction,\n  {\n    action,\n    interactable,\n    element,\n  }: {\n    action: ActionProps<any>\n    interactable: Interactable\n    element: Element\n  },\n  scope: Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name ? interactable.getRect(element) : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit<T extends ActionName> (\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  scope: Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) {\n    return false\n  }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) {\n      continue\n    }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) {\n      continue\n    }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions (newValue: any, scope: Scope) {\n  if (is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor (element: Element, cursor: string, scope: Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement && prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor<T extends ActionName> (interaction: Interaction<T>, scope: Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    } else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Plugin = {\n  id: 'auto-start/base',\n  before: ['actions'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n}\n\nexport default autoStart\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { SignalArgs, Scope } from '@interactjs/core/scope'\nimport type { ActionName, Element } from '@interactjs/core/types'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\n\nimport autoStart from './base'\n\nfunction beforeStart ({ interaction, eventTarget, dx, dy }: SignalArgs['interactions:move'], scope: Scope) {\n  if (interaction.prepared.name !== 'drag') return\n\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx)\n  const absY = Math.abs(dy)\n  const targetOptions = interaction.interactable.options.drag\n  const startAxis = targetOptions.startAxis\n  const currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy'\n\n  interaction.prepared.axis =\n    targetOptions.lockAxis === 'start'\n      ? (currentAxis[0] as 'x' | 'y') // always lock to one axis even if currentAxis === 'xy'\n      : targetOptions.lockAxis\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    ;(interaction as Interaction<ActionName>).prepared.name = null\n\n    // then try to get a drag from another ineractable\n    let element = eventTarget as Element\n\n    const getDraggable = function (interactable: Interactable): Interactable | void {\n      if (interactable === interaction.interactable) return\n\n      const options = interaction.interactable.options.drag\n\n      if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {\n        const action = interactable.getAction(\n          interaction.downPointer,\n          interaction.downEvent,\n          interaction,\n          element,\n        )\n\n        if (\n          action &&\n          action.name === 'drag' &&\n          checkStartAxis(currentAxis, interactable) &&\n          autoStart.validateAction(action, interactable, element, eventTarget, scope)\n        ) {\n          return interactable\n        }\n      }\n    }\n\n    // check all interactables\n    while (is.element(element)) {\n      const interactable = scope.interactables.forEachMatch(element, getDraggable)\n\n      if (interactable) {\n        ;(interaction as Interaction<ActionName>).prepared.name = 'drag'\n        interaction.interactable = interactable\n        interaction.element = element\n        break\n      }\n\n      element = parentNode(element) as Element\n    }\n  }\n}\n\nfunction checkStartAxis (startAxis: string, interactable: Interactable) {\n  if (!interactable) {\n    return false\n  }\n\n  const thisAxis = interactable.options.drag.startAxis\n\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis\n}\n\nexport default {\n  id: 'auto-start/dragAxis',\n  listeners: { 'autoStart:before-start': beforeStart },\n}\n", "import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\n\nimport basePlugin from './base'\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    hold?: number\n    delay?: number\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoStartHoldTimer?: any\n  }\n}\n\nfunction install (scope: Scope) {\n  const { defaults } = scope\n\n  scope.usePlugin(basePlugin)\n\n  defaults.perAction.hold = 0\n  defaults.perAction.delay = 0\n}\n\nfunction getHoldDuration (interaction: Interaction) {\n  const actionName = interaction.prepared && interaction.prepared.name\n\n  if (!actionName) {\n    return null\n  }\n\n  const options = interaction.interactable.options\n\n  return options[actionName].hold || options[actionName].delay\n}\n\nconst hold: Plugin = {\n  id: 'auto-start/hold',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoStartHoldTimer = null\n    },\n\n    'autoStart:prepared': ({ interaction }) => {\n      const hold = getHoldDuration(interaction)\n\n      if (hold > 0) {\n        interaction.autoStartHoldTimer = setTimeout(() => {\n          interaction.start(interaction.prepared, interaction.interactable, interaction.element)\n        }, hold)\n      }\n    },\n\n    'interactions:move': ({ interaction, duplicate }) => {\n      if (interaction.autoStartHoldTimer && interaction.pointerWasMoved && !duplicate) {\n        clearTimeout(interaction.autoStartHoldTimer)\n        interaction.autoStartHoldTimer = null\n      }\n    },\n\n    // prevent regular down->move autoStart\n    'autoStart:before-start': ({ interaction }) => {\n      const holdDuration = getHoldDuration(interaction)\n\n      if (holdDuration > 0) {\n        interaction.prepared.name = null\n      }\n    },\n  },\n  getHoldDuration,\n}\nexport default hold\n", "import type { Scope } from '@interactjs/core/scope'\n\nimport autoStart from './base'\nimport dragAxis from './dragAxis'\nimport hold from './hold'\n\nexport default {\n  id: 'auto-start',\n  install (scope: Scope) {\n    scope.usePlugin(autoStart)\n    scope.usePlugin(hold)\n    scope.usePlugin(dragAxis)\n  },\n}\n", "/* eslint-disable no-console, eol-last, import/no-duplicates,  import/no-extraneous-dependencies, import/order */\nimport '@interactjs/auto-start/plugin'\nimport interact from '@interactjs/interact/index'\nimport plugin from '@interactjs/auto-start/plugin'\ninteract.use(plugin)"],
  "mappings": "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",
  "names": ["install", "scope", "Interactable", "prototype", "getAction", "pointer", "event", "interaction", "element", "action", "defaultActionChecker", "options", "actionChecker", "ignoreFrom", "warnOnce", "newValue", "_backCompatOption", "allowFrom", "styleCursor", "interactable", "rect", "getRect", "buttons", "button", "arg", "fire", "is", "bool", "checker", "func", "id", "install", "scope", "interactStatic", "interact", "defaults", "usePlugin", "InteractableMethods", "base", "actionChecker", "styleCursor", "extend", "perAction", "manualStart", "max", "Infinity", "maxPerElement", "allowFrom", "ignoreFrom", "mouseButtons", "maxInteractions", "newValue", "autoStart", "withinInteractionLimit", "cursorElement", "prepareOnDown", "interaction", "pointer", "event", "eventTarget", "interacting", "actionInfo", "getActionInfo", "prepare", "prepareOnMove", "pointerType", "pointerIsDown", "startOnMove", "arg", "pointerWasMoved", "prepared", "name", "fire", "interactable", "actionName", "options", "element", "stop", "start", "setInteractionCursor", "clearCursorOnStop", "setCursor", "validateAction", "action", "testIgnoreAllow", "enabled", "validateMatches", "matches", "matchElements", "i", "len", "length", "match", "matchElement", "matchAction", "getAction", "pushMatches", "push", "is", "interactables", "forEachMatch", "parentNode", "copyAction", "rect", "getRect", "maxActions", "autoStartMax", "activeInteractions", "interactableCount", "elementCount", "interactions", "list", "otherAction", "number", "cursor", "prevCursorElement", "style", "ownerDocument", "documentElement", "cursorChecker", "func", "_interacting", "actions", "map", "getCursor", "id", "before", "listeners", "beforeStart", "interaction", "eventTarget", "dx", "dy", "scope", "prepared", "name", "absX", "Math", "abs", "absY", "targetOptions", "interactable", "options", "drag", "startAxis", "currentAxis", "axis", "lockAxis", "element", "getDraggable", "manualStart", "testIgnoreAllow", "action", "getAction", "downPointer", "downEvent", "checkStartAxis", "autoStart", "validateAction", "is", "interactables", "forEachMatch", "parentNode", "thisAxis", "id", "listeners", "install", "scope", "defaults", "usePlugin", "basePlugin", "perAction", "hold", "delay", "getHoldDuration", "interaction", "actionName", "prepared", "name", "options", "interactable", "id", "listeners", "autoStartHoldTimer", "setTimeout", "start", "element", "duplicate", "pointerWasMoved", "clearTimeout", "holdDuration", "id", "install", "scope", "usePlugin", "autoStart", "hold", "dragAxis", "interact", "use", "plugin"]
}
