{
  "version": 3,
  "sources": ["../../../../node_modules/@interactjs/snappers/all.ts", "../../../../node_modules/@interactjs/snappers/edgeTarget.ts", "../../../../node_modules/@interactjs/snappers/elements.ts", "../../../../node_modules/@interactjs/snappers/grid.ts", "../../../../node_modules/@interactjs/snappers/plugin.ts", "../../../../node_modules/@interactjs/modifiers/Modification.ts", "../../../../node_modules/@interactjs/modifiers/base.ts", "../../../../node_modules/@interactjs/modifiers/aspectRatio.ts", "../../../../node_modules/@interactjs/modifiers/noop.ts", "../../../../node_modules/@interactjs/modifiers/restrict/pointer.ts", "../../../../node_modules/@interactjs/modifiers/restrict/edges.ts", "../../../../node_modules/@interactjs/modifiers/restrict/rect.ts", "../../../../node_modules/@interactjs/modifiers/restrict/size.ts", "../../../../node_modules/@interactjs/modifiers/snap/pointer.ts", "../../../../node_modules/@interactjs/modifiers/snap/size.ts", "../../../../node_modules/@interactjs/modifiers/snap/edges.ts", "../../../../node_modules/@interactjs/modifiers/all.ts", "../../../../node_modules/@interactjs/modifiers/plugin.ts", "../../../../node_modules/@interactjs/modifiers/index.ts"],
  "sourcesContent": ["/* eslint-disable import/no-named-as-default, import/no-unresolved */\nexport { default as edgeTarget } from './edgeTarget'\nexport { default as elements } from './elements'\nexport { default as grid } from './grid'\n", "export default () => {}\n", "export default () => {}\n", "import type { Rect, Point } from '@interactjs/core/types'\nimport type { SnapFunction, SnapTarget } from '@interactjs/modifiers/snap/pointer'\n\nexport type GridOptions = (Partial<Rect> | Point) & {\n  range?: number\n  limits?: Rect\n  offset?: Point\n}\n\nexport default (grid: GridOptions) => {\n  const coordFields = (\n    [\n      ['x', 'y'],\n      ['left', 'top'],\n      ['right', 'bottom'],\n      ['width', 'height'],\n    ] as const\n  ).filter(([xField, yField]) => xField in grid || yField in grid)\n\n  const gridFunc: SnapFunction & {\n    grid: typeof grid\n    coordFields: typeof coordFields\n  } = (x, y) => {\n    const {\n      range,\n      limits = {\n        left: -Infinity,\n        right: Infinity,\n        top: -Infinity,\n        bottom: Infinity,\n      },\n      offset = { x: 0, y: 0 },\n    } = grid\n\n    const result: SnapTarget & {\n      grid: typeof grid\n    } = { range, grid, x: null as number, y: null as number }\n\n    for (const [xField, yField] of coordFields) {\n      const gridx = Math.round((x - offset.x) / (grid as any)[xField])\n      const gridy = Math.round((y - offset.y) / (grid as any)[yField])\n\n      result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * (grid as any)[xField] + offset.x))\n      result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * (grid as any)[yField] + offset.y))\n    }\n\n    return result\n  }\n\n  gridFunc.grid = grid\n  gridFunc.coordFields = coordFields\n\n  return gridFunc\n}\n", "import type { Plugin } from '@interactjs/core/scope'\nimport extend from '@interactjs/utils/extend'\n\nimport * as allSnappers from './all'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    snappers: typeof allSnappers\n    createSnapGrid: typeof allSnappers.grid\n  }\n}\n\nconst snappersPlugin: Plugin = {\n  id: 'snappers',\n  install (scope) {\n    const { interactStatic: interact } = scope\n\n    interact.snappers = extend(interact.snappers || {}, allSnappers)\n    interact.createSnapGrid = interact.snappers.grid\n  },\n}\n\nexport default snappersPlugin\n", "import type { EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoAnyPhaseArg } from '@interactjs/core/Interaction'\nimport type { EdgeOptions, FullRect, Point, Rect } from '@interactjs/core/types'\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { Modifier, ModifierArg, ModifierState } from './types'\n\nexport interface ModificationResult {\n  delta: Point\n  rectDelta: Rect\n  coords: Point\n  rect: FullRect\n  eventProps: any[]\n  changed: boolean\n}\n\ninterface MethodArg {\n  phase: EventPhase\n  pageCoords: Point\n  rect: FullRect\n  coords: Point\n  preEnd?: boolean\n  skipModifiers?: number\n}\n\nexport default class Modification {\n  states: ModifierState[] = []\n  startOffset: Rect = { left: 0, right: 0, top: 0, bottom: 0 }\n  startDelta!: Point\n  result!: ModificationResult\n  endResult!: Point\n  startEdges!: EdgeOptions\n  edges: EdgeOptions\n  readonly interaction: Readonly<Interaction>\n\n  constructor (interaction: Interaction) {\n    this.interaction = interaction\n    this.result = createResult()\n    this.edges = {\n      left: false,\n      right: false,\n      top: false,\n      bottom: false,\n    }\n  }\n\n  start ({ phase }: { phase: EventPhase }, pageCoords: Point) {\n    const { interaction } = this\n    const modifierList = getModifierList(interaction)\n    this.prepareStates(modifierList)\n\n    this.startEdges = extend({}, interaction.edges)\n    this.edges = extend({}, this.startEdges)\n    this.startOffset = getRectOffset(interaction.rect, pageCoords)\n    this.startDelta = { x: 0, y: 0 }\n\n    const arg = this.fillArg({\n      phase,\n      pageCoords,\n      preEnd: false,\n    })\n\n    this.result = createResult()\n    this.startAll(arg)\n\n    const result = (this.result = this.setAll(arg))\n\n    return result\n  }\n\n  fillArg (arg: Partial<ModifierArg>) {\n    const { interaction } = this\n\n    arg.interaction = interaction\n    arg.interactable = interaction.interactable\n    arg.element = interaction.element\n    arg.rect ||= interaction.rect\n    arg.edges ||= this.startEdges\n    arg.startOffset = this.startOffset\n\n    return arg as ModifierArg\n  }\n\n  startAll (arg: MethodArg & Partial<ModifierArg>) {\n    for (const state of this.states) {\n      if (state.methods.start) {\n        arg.state = state\n        state.methods.start(arg as ModifierArg)\n      }\n    }\n  }\n\n  setAll (arg: MethodArg & Partial<ModifierArg>): ModificationResult {\n    const { phase, preEnd, skipModifiers, rect: unmodifiedRect, edges: unmodifiedEdges } = arg\n\n    arg.coords = extend({}, arg.pageCoords)\n    arg.rect = extend({}, unmodifiedRect)\n    arg.edges = extend({}, unmodifiedEdges)\n\n    const states = skipModifiers ? this.states.slice(skipModifiers) : this.states\n\n    const newResult = createResult(arg.coords, arg.rect)\n\n    for (const state of states) {\n      const { options } = state\n      const lastModifierCoords = extend({}, arg.coords)\n      let returnValue = null\n\n      if (state.methods?.set && this.shouldDo(options, preEnd, phase)) {\n        arg.state = state\n        returnValue = state.methods.set(arg as ModifierArg<never>)\n\n        rectUtils.addEdges(arg.edges, arg.rect, {\n          x: arg.coords.x - lastModifierCoords.x,\n          y: arg.coords.y - lastModifierCoords.y,\n        })\n      }\n\n      newResult.eventProps.push(returnValue)\n    }\n\n    extend(this.edges, arg.edges)\n\n    newResult.delta.x = arg.coords.x - arg.pageCoords.x\n    newResult.delta.y = arg.coords.y - arg.pageCoords.y\n\n    newResult.rectDelta.left = arg.rect.left - unmodifiedRect.left\n    newResult.rectDelta.right = arg.rect.right - unmodifiedRect.right\n    newResult.rectDelta.top = arg.rect.top - unmodifiedRect.top\n    newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom\n\n    const prevCoords = this.result.coords\n    const prevRect = this.result.rect\n\n    if (prevCoords && prevRect) {\n      const rectChanged =\n        newResult.rect.left !== prevRect.left ||\n        newResult.rect.right !== prevRect.right ||\n        newResult.rect.top !== prevRect.top ||\n        newResult.rect.bottom !== prevRect.bottom\n\n      newResult.changed =\n        rectChanged || prevCoords.x !== newResult.coords.x || prevCoords.y !== newResult.coords.y\n    }\n\n    return newResult\n  }\n\n  applyToInteraction (arg: { phase: EventPhase, rect?: Rect }) {\n    const { interaction } = this\n    const { phase } = arg\n    const curCoords = interaction.coords.cur\n    const startCoords = interaction.coords.start\n    const { result, startDelta } = this\n    const curDelta = result.delta\n\n    if (phase === 'start') {\n      extend(this.startDelta, result.delta)\n    }\n\n    for (const [coordsSet, delta] of [\n      [startCoords, startDelta],\n      [curCoords, curDelta],\n    ] as const) {\n      coordsSet.page.x += delta.x\n      coordsSet.page.y += delta.y\n      coordsSet.client.x += delta.x\n      coordsSet.client.y += delta.y\n    }\n\n    const { rectDelta } = this.result\n    const rect = arg.rect || interaction.rect\n\n    rect.left += rectDelta.left\n    rect.right += rectDelta.right\n    rect.top += rectDelta.top\n    rect.bottom += rectDelta.bottom\n\n    rect.width = rect.right - rect.left\n    rect.height = rect.bottom - rect.top\n  }\n\n  setAndApply (\n    arg: Partial<DoAnyPhaseArg> & {\n      phase: EventPhase\n      preEnd?: boolean\n      skipModifiers?: number\n      modifiedCoords?: Point\n    },\n  ): void | false {\n    const { interaction } = this\n    const { phase, preEnd, skipModifiers } = arg\n\n    const result = this.setAll(\n      this.fillArg({\n        preEnd,\n        phase,\n        pageCoords: arg.modifiedCoords || interaction.coords.cur.page,\n      }),\n    )\n\n    this.result = result\n\n    // don't fire an action move if a modifier would keep the event in the same\n    // cordinates as before\n    if (\n      !result.changed &&\n      (!skipModifiers || skipModifiers < this.states.length) &&\n      interaction.interacting()\n    ) {\n      return false\n    }\n\n    if (arg.modifiedCoords) {\n      const { page } = interaction.coords.cur\n      const adjustment = {\n        x: arg.modifiedCoords.x - page.x,\n        y: arg.modifiedCoords.y - page.y,\n      }\n\n      result.coords.x += adjustment.x\n      result.coords.y += adjustment.y\n      result.delta.x += adjustment.x\n      result.delta.y += adjustment.y\n    }\n\n    this.applyToInteraction(arg)\n  }\n\n  beforeEnd (arg: Omit<DoAnyPhaseArg, 'iEvent'> & { state?: ModifierState }): void | false {\n    const { interaction, event } = arg\n    const states = this.states\n\n    if (!states || !states.length) {\n      return\n    }\n\n    let doPreend = false\n\n    for (const state of states) {\n      arg.state = state\n      const { options, methods } = state\n\n      const endPosition = methods.beforeEnd && methods.beforeEnd(arg as unknown as ModifierArg)\n\n      if (endPosition) {\n        this.endResult = endPosition\n        return false\n      }\n\n      doPreend = doPreend || (!doPreend && this.shouldDo(options, true, arg.phase, true))\n    }\n\n    if (doPreend) {\n      // trigger a final modified move before ending\n      interaction.move({ event, preEnd: true })\n    }\n  }\n\n  stop (arg: { interaction: Interaction }) {\n    const { interaction } = arg\n\n    if (!this.states || !this.states.length) {\n      return\n    }\n\n    const modifierArg: Partial<ModifierArg> = extend(\n      {\n        states: this.states,\n        interactable: interaction.interactable,\n        element: interaction.element,\n        rect: null,\n      },\n      arg,\n    )\n\n    this.fillArg(modifierArg)\n\n    for (const state of this.states) {\n      modifierArg.state = state\n\n      if (state.methods.stop) {\n        state.methods.stop(modifierArg as ModifierArg)\n      }\n    }\n\n    this.states = null\n    this.endResult = null\n  }\n\n  prepareStates (modifierList: Modifier[]) {\n    this.states = []\n\n    for (let index = 0; index < modifierList.length; index++) {\n      const { options, methods, name } = modifierList[index]\n\n      this.states.push({\n        options,\n        methods,\n        index,\n        name,\n      })\n    }\n\n    return this.states\n  }\n\n  restoreInteractionCoords ({ interaction: { coords, rect, modification } }: { interaction: Interaction }) {\n    if (!modification.result) return\n\n    const { startDelta } = modification\n    const { delta: curDelta, rectDelta } = modification.result\n\n    const coordsAndDeltas = [\n      [coords.start, startDelta],\n      [coords.cur, curDelta],\n    ]\n\n    for (const [coordsSet, delta] of coordsAndDeltas as any) {\n      coordsSet.page.x -= delta.x\n      coordsSet.page.y -= delta.y\n      coordsSet.client.x -= delta.x\n      coordsSet.client.y -= delta.y\n    }\n\n    rect.left -= rectDelta.left\n    rect.right -= rectDelta.right\n    rect.top -= rectDelta.top\n    rect.bottom -= rectDelta.bottom\n  }\n\n  shouldDo (options, preEnd?: boolean, phase?: string, requireEndOnly?: boolean) {\n    if (\n      // ignore disabled modifiers\n      !options ||\n      options.enabled === false ||\n      // check if we require endOnly option to fire move before end\n      (requireEndOnly && !options.endOnly) ||\n      // don't apply endOnly modifiers when not ending\n      (options.endOnly && !preEnd) ||\n      // check if modifier should run be applied on start\n      (phase === 'start' && !options.setStart)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  copyFrom (other: Modification) {\n    this.startOffset = other.startOffset\n    this.startDelta = other.startDelta\n    this.startEdges = other.startEdges\n    this.edges = other.edges\n    this.states = other.states.map((s) => clone(s) as ModifierState)\n    this.result = createResult(extend({}, other.result.coords), extend({}, other.result.rect))\n  }\n\n  destroy () {\n    for (const prop in this) {\n      this[prop] = null\n    }\n  }\n}\n\nfunction createResult (coords?: Point, rect?: FullRect): ModificationResult {\n  return {\n    rect,\n    coords,\n    delta: { x: 0, y: 0 },\n    rectDelta: {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0,\n    },\n    eventProps: [],\n    changed: true,\n  }\n}\n\nfunction getModifierList (interaction) {\n  const actionOptions = interaction.interactable.options[interaction.prepared.name]\n  const actionModifiers = actionOptions.modifiers\n\n  if (actionModifiers && actionModifiers.length) {\n    return actionModifiers\n  }\n\n  return ['snap', 'snapSize', 'snapEdges', 'restrict', 'restrictEdges', 'restrictSize']\n    .map((type) => {\n      const options = actionOptions[type]\n\n      return (\n        options &&\n        options.enabled && {\n          options,\n          methods: options._methods,\n        }\n      )\n    })\n    .filter((m) => !!m)\n}\n\nexport function getRectOffset (rect, coords) {\n  return rect\n    ? {\n      left: coords.x - rect.left,\n      top: coords.y - rect.top,\n      right: rect.right - coords.x,\n      bottom: rect.bottom - coords.y,\n    }\n    : {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n    }\n}\n", "import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Plugin } from '@interactjs/core/scope'\n\nimport Modification from './Modification'\nimport type { Modifier, ModifierModule, ModifierState } from './types'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    modification?: Modification\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface InteractEvent {\n    modifiers?: Array<{\n      name: string\n      [key: string]: any\n    }>\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    modifiers?: Modifier[]\n  }\n}\n\nexport function makeModifier<\n  Defaults extends { enabled?: boolean },\n  State extends ModifierState,\n  Name extends string,\n  Result,\n> (module: ModifierModule<Defaults, State, Result>, name?: Name) {\n  const { defaults } = module\n  const methods = {\n    start: module.start,\n    set: module.set,\n    beforeEnd: module.beforeEnd,\n    stop: module.stop,\n  }\n\n  const modifier = (_options?: Partial<Defaults>) => {\n    const options = (_options || {}) as Defaults\n\n    options.enabled = options.enabled !== false\n\n    // add missing defaults to options\n    for (const prop in defaults) {\n      if (!(prop in options)) {\n        ;(options as any)[prop] = defaults[prop]\n      }\n    }\n\n    const m: Modifier<Defaults, State, Name, Result> = {\n      options,\n      methods,\n      name,\n      enable: () => {\n        options.enabled = true\n        return m\n      },\n      disable: () => {\n        options.enabled = false\n        return m\n      },\n    }\n\n    return m\n  }\n\n  if (name && typeof name === 'string') {\n    // for backwrads compatibility\n    modifier._defaults = defaults\n    modifier._methods = methods\n  }\n\n  return modifier\n}\n\nexport function addEventModifiers ({\n  iEvent,\n  interaction,\n}: {\n  iEvent: InteractEvent<any>\n  interaction: Interaction<any>\n}) {\n  const result = interaction.modification!.result\n\n  if (result) {\n    iEvent.modifiers = result.eventProps\n  }\n}\n\nconst modifiersBase: Plugin = {\n  id: 'modifiers/base',\n  before: ['actions'],\n  install: (scope) => {\n    scope.defaults.perAction.modifiers = []\n  },\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.modification = new Modification(interaction)\n    },\n\n    'interactions:before-action-start': (arg) => {\n      const { interaction } = arg\n      const modification = arg.interaction.modification!\n\n      modification.start(arg, interaction.coords.start.page)\n      interaction.edges = modification.edges\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-move': (arg) => {\n      const { interaction } = arg\n      const { modification } = interaction\n      const ret = modification.setAndApply(arg)\n      interaction.edges = modification.edges\n\n      return ret\n    },\n\n    'interactions:before-action-end': (arg) => {\n      const { interaction } = arg\n      const { modification } = interaction\n      const ret = modification.beforeEnd(arg)\n      interaction.edges = modification.startEdges\n\n      return ret\n    },\n\n    'interactions:action-start': addEventModifiers,\n    'interactions:action-move': addEventModifiers,\n    'interactions:action-end': addEventModifiers,\n\n    'interactions:after-action-start': (arg) => arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-move': (arg) => arg.interaction.modification.restoreInteractionCoords(arg),\n\n    'interactions:stop': (arg) => arg.interaction.modification.stop(arg),\n  },\n}\n\nexport default modifiersBase\n", "/**\n * @module modifiers/aspectRatio\n *\n * @description\n * This module forces elements to be resized with a specified dx/dy ratio.\n *\n * ```js\n * interact(target).resizable({\n *   modifiers: [\n *     interact.modifiers.snapSize({\n *       targets: [ interact.snappers.grid({ x: 20, y: 20 }) ],\n *     }),\n *     interact.aspectRatio({ ratio: 'preserve' }),\n *   ],\n * });\n * ```\n */\n\nimport type { Point, Rect, EdgeOptions } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport { addEdges } from '@interactjs/utils/rect'\n\nimport Modification from './Modification'\nimport { makeModifier } from './base'\nimport type { Modifier, ModifierModule, ModifierState } from './types'\n\nexport interface AspectRatioOptions {\n  ratio?: number | 'preserve'\n  equalDelta?: boolean\n  modifiers?: Modifier[]\n  enabled?: boolean\n}\n\nexport type AspectRatioState = ModifierState<\nAspectRatioOptions,\n{\n  startCoords: Point\n  startRect: Rect\n  linkedEdges: EdgeOptions\n  ratio: number\n  equalDelta: boolean\n  xIsPrimaryAxis: boolean\n  edgeSign: {\n    x: number\n    y: number\n  }\n  subModification: Modification\n}\n>\n\nconst aspectRatio: ModifierModule<AspectRatioOptions, AspectRatioState> = {\n  start (arg) {\n    const { state, rect, edges, pageCoords: coords } = arg\n    let { ratio, enabled } = state.options\n    const { equalDelta, modifiers } = state.options\n\n    if (ratio === 'preserve') {\n      ratio = rect.width / rect.height\n    }\n\n    state.startCoords = extend({}, coords)\n    state.startRect = extend({}, rect)\n    state.ratio = ratio\n    state.equalDelta = equalDelta\n\n    const linkedEdges = (state.linkedEdges = {\n      top: edges.top || (edges.left && !edges.bottom),\n      left: edges.left || (edges.top && !edges.right),\n      bottom: edges.bottom || (edges.right && !edges.top),\n      right: edges.right || (edges.bottom && !edges.left),\n    })\n\n    state.xIsPrimaryAxis = !!(edges.left || edges.right)\n\n    if (state.equalDelta) {\n      const sign = (linkedEdges.left ? 1 : -1) * (linkedEdges.top ? 1 : -1)\n      state.edgeSign = {\n        x: sign,\n        y: sign,\n      }\n    } else {\n      state.edgeSign = {\n        x: linkedEdges.left ? -1 : 1,\n        y: linkedEdges.top ? -1 : 1,\n      }\n    }\n\n    if (enabled !== false) {\n      extend(edges, linkedEdges)\n    }\n\n    if (!modifiers?.length) return\n\n    const subModification = new Modification(arg.interaction)\n\n    subModification.copyFrom(arg.interaction.modification)\n    subModification.prepareStates(modifiers)\n\n    state.subModification = subModification\n    subModification.startAll({ ...arg })\n  },\n\n  set (arg) {\n    const { state, rect, coords } = arg\n    const { linkedEdges } = state\n    const initialCoords = extend({}, coords)\n    const aspectMethod = state.equalDelta ? setEqualDelta : setRatio\n\n    extend(arg.edges, linkedEdges)\n    aspectMethod(state, state.xIsPrimaryAxis, coords, rect)\n\n    if (!state.subModification) {\n      return null\n    }\n\n    const correctedRect = extend({}, rect)\n\n    addEdges(linkedEdges, correctedRect, {\n      x: coords.x - initialCoords.x,\n      y: coords.y - initialCoords.y,\n    })\n\n    const result = state.subModification.setAll({\n      ...arg,\n      rect: correctedRect,\n      edges: linkedEdges,\n      pageCoords: coords,\n      prevCoords: coords,\n      prevRect: correctedRect,\n    })\n\n    const { delta } = result\n\n    if (result.changed) {\n      const xIsCriticalAxis = Math.abs(delta.x) > Math.abs(delta.y)\n\n      // do aspect modification again with critical edge axis as primary\n      aspectMethod(state, xIsCriticalAxis, result.coords, result.rect)\n      extend(coords, result.coords)\n    }\n\n    return result.eventProps\n  },\n\n  defaults: {\n    ratio: 'preserve',\n    equalDelta: false,\n    modifiers: [],\n    enabled: false,\n  },\n}\n\nfunction setEqualDelta ({ startCoords, edgeSign }: AspectRatioState, xIsPrimaryAxis: boolean, coords: Point) {\n  if (xIsPrimaryAxis) {\n    coords.y = startCoords.y + (coords.x - startCoords.x) * edgeSign.y\n  } else {\n    coords.x = startCoords.x + (coords.y - startCoords.y) * edgeSign.x\n  }\n}\n\nfunction setRatio (\n  { startRect, startCoords, ratio, edgeSign }: AspectRatioState,\n  xIsPrimaryAxis: boolean,\n  coords: Point,\n  rect: Rect,\n) {\n  if (xIsPrimaryAxis) {\n    const newHeight = rect.width / ratio\n\n    coords.y = startCoords.y + (newHeight - startRect.height) * edgeSign.y\n  } else {\n    const newWidth = rect.height * ratio\n\n    coords.x = startCoords.x + (newWidth - startRect.width) * edgeSign.x\n  }\n}\n\nexport default makeModifier(aspectRatio, 'aspectRatio')\nexport { aspectRatio }\n", "import type { ModifierFunction } from './types'\n\nconst noop = (() => {}) as unknown as ModifierFunction<any, any, 'noop'>\n\nnoop._defaults = {}\n\nexport default noop\n", "import type Interaction from '@interactjs/core/Interaction'\nimport type { RectResolvable, Rect, Point } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierModule, ModifierState } from '../types'\n\nexport interface RestrictOptions {\n  // where to drag over\n  restriction: RectResolvable<[number, number, Interaction]>\n  // what part of self is allowed to drag over\n  elementRect: Rect\n  offset: Rect\n  // restrict just before the end drag\n  endOnly: boolean\n  enabled?: boolean\n}\n\nexport type RestrictState = ModifierState<\nRestrictOptions,\n{\n  offset: Rect\n}\n>\n\nfunction start ({ rect, startOffset, state, interaction, pageCoords }: ModifierArg<RestrictState>) {\n  const { options } = state\n  const { elementRect } = options\n  const offset: Rect = extend(\n    {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0,\n    },\n    options.offset || {},\n  )\n\n  if (rect && elementRect) {\n    const restriction = getRestrictionRect(options.restriction, interaction, pageCoords)\n\n    if (restriction) {\n      const widthDiff = restriction.right - restriction.left - rect.width\n      const heightDiff = restriction.bottom - restriction.top - rect.height\n\n      if (widthDiff < 0) {\n        offset.left += widthDiff\n        offset.right += widthDiff\n      }\n      if (heightDiff < 0) {\n        offset.top += heightDiff\n        offset.bottom += heightDiff\n      }\n    }\n\n    offset.left += startOffset.left - rect.width * elementRect.left\n    offset.top += startOffset.top - rect.height * elementRect.top\n\n    offset.right += startOffset.right - rect.width * (1 - elementRect.right)\n    offset.bottom += startOffset.bottom - rect.height * (1 - elementRect.bottom)\n  }\n\n  state.offset = offset\n}\n\nfunction set ({ coords, interaction, state }: ModifierArg<RestrictState>) {\n  const { options, offset } = state\n\n  const restriction = getRestrictionRect(options.restriction, interaction, coords)\n\n  if (!restriction) return\n\n  const rect = rectUtils.xywhToTlbr(restriction)\n\n  coords.x = Math.max(Math.min(rect.right - offset.right, coords.x), rect.left + offset.left)\n  coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top + offset.top)\n}\n\nexport function getRestrictionRect (\n  value: RectResolvable<[number, number, Interaction]>,\n  interaction: Interaction,\n  coords?: Point,\n) {\n  if (is.func(value)) {\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element, [\n      coords.x,\n      coords.y,\n      interaction,\n    ])\n  } else {\n    return rectUtils.resolveRectLike(value, interaction.interactable, interaction.element)\n  }\n}\n\nconst defaults: RestrictOptions = {\n  restriction: null,\n  elementRect: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrict: ModifierModule<RestrictOptions, RestrictState> = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrict, 'restrict')\nexport { restrict }\n", "// This module adds the options.resize.restrictEdges setting which sets min and\n// max for the top, left, bottom and right edges of the target being resized.\n//\n// interact(target).resize({\n//   edges: { top: true, left: true },\n//   restrictEdges: {\n//     inner: { top: 200, left: 200, right: 400, bottom: 400 },\n//     outer: { top:   0, left:   0, right: 600, bottom: 600 },\n//   },\n// })\n\nimport type { Point, Rect } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierState } from '../types'\n\nimport type { RestrictOptions } from './pointer'\nimport { getRestrictionRect } from './pointer'\n\nexport interface RestrictEdgesOptions {\n  inner: RestrictOptions['restriction']\n  outer: RestrictOptions['restriction']\n  offset?: RestrictOptions['offset']\n  endOnly: boolean\n  enabled?: boolean\n}\n\nexport type RestrictEdgesState = ModifierState<\nRestrictEdgesOptions,\n{\n  inner: Rect\n  outer: Rect\n  offset: RestrictEdgesOptions['offset']\n}\n>\n\nconst noInner = { top: +Infinity, left: +Infinity, bottom: -Infinity, right: -Infinity }\nconst noOuter = { top: -Infinity, left: -Infinity, bottom: +Infinity, right: +Infinity }\n\nfunction start ({ interaction, startOffset, state }: ModifierArg<RestrictEdgesState>) {\n  const { options } = state\n  let offset: Point\n\n  if (options) {\n    const offsetRect = getRestrictionRect(options.offset, interaction, interaction.coords.start.page)\n\n    offset = rectUtils.rectToXY(offsetRect)\n  }\n\n  offset = offset || { x: 0, y: 0 }\n\n  state.offset = {\n    top: offset.y + startOffset.top,\n    left: offset.x + startOffset.left,\n    bottom: offset.y - startOffset.bottom,\n    right: offset.x - startOffset.right,\n  }\n}\n\nfunction set ({ coords, edges, interaction, state }: ModifierArg<RestrictEdgesState>) {\n  const { offset, options } = state\n\n  if (!edges) {\n    return\n  }\n\n  const page = extend({}, coords)\n  const inner = getRestrictionRect(options.inner, interaction, page) || ({} as Rect)\n  const outer = getRestrictionRect(options.outer, interaction, page) || ({} as Rect)\n\n  fixRect(inner, noInner)\n  fixRect(outer, noOuter)\n\n  if (edges.top) {\n    coords.y = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top)\n  } else if (edges.bottom) {\n    coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom)\n  }\n  if (edges.left) {\n    coords.x = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left)\n  } else if (edges.right) {\n    coords.x = Math.max(Math.min(outer.right + offset.right, page.x), inner.right + offset.right)\n  }\n}\n\nfunction fixRect (rect: Rect, defaults: Rect) {\n  for (const edge of ['top', 'left', 'bottom', 'right']) {\n    if (!(edge in rect)) {\n      rect[edge] = defaults[edge]\n    }\n  }\n\n  return rect\n}\n\nconst defaults: RestrictEdgesOptions = {\n  inner: null,\n  outer: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrictEdges = {\n  noInner,\n  noOuter,\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrictEdges, 'restrictEdges')\nexport { restrictEdges }\n", "import extend from '@interactjs/utils/extend'\n\nimport { makeModifier } from '../base'\n\nimport { restrict } from './pointer'\n\nconst defaults = extend(\n  {\n    get elementRect () {\n      return { top: 0, left: 0, bottom: 1, right: 1 }\n    },\n    set elementRect (_) {},\n  },\n  restrict.defaults,\n)\n\nconst restrictRect = {\n  start: restrict.start,\n  set: restrict.set,\n  defaults,\n}\n\nexport default makeModifier(restrictRect, 'restrictRect')\nexport { restrictRect }\n", "import type { Point, Rect, Size } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierState } from '../types'\n\nimport type { RestrictEdgesState } from './edges'\nimport { restrictEdges } from './edges'\nimport type { RestrictOptions } from './pointer'\nimport { getRestrictionRect } from './pointer'\n\nconst noMin = { width: -Infinity, height: -Infinity }\nconst noMax = { width: +Infinity, height: +Infinity }\n\nexport interface RestrictSizeOptions {\n  min?: Size | Point | RestrictOptions['restriction']\n  max?: Size | Point | RestrictOptions['restriction']\n  endOnly: boolean\n  enabled?: boolean\n}\n\nfunction start (arg: ModifierArg<RestrictEdgesState>) {\n  return restrictEdges.start(arg)\n}\n\nexport type RestrictSizeState = RestrictEdgesState &\nModifierState<\nRestrictSizeOptions & { inner: Rect, outer: Rect },\n{\n  min: Rect\n  max: Rect\n}\n>\n\nfunction set (arg: ModifierArg<RestrictSizeState>) {\n  const { interaction, state, rect, edges } = arg\n  const { options } = state\n\n  if (!edges) {\n    return\n  }\n\n  const minSize =\n    rectUtils.tlbrToXywh(getRestrictionRect(options.min as any, interaction, arg.coords)) || noMin\n  const maxSize =\n    rectUtils.tlbrToXywh(getRestrictionRect(options.max as any, interaction, arg.coords)) || noMax\n\n  state.options = {\n    endOnly: options.endOnly,\n    inner: extend({}, restrictEdges.noInner),\n    outer: extend({}, restrictEdges.noOuter),\n  }\n\n  if (edges.top) {\n    state.options.inner.top = rect.bottom - minSize.height\n    state.options.outer.top = rect.bottom - maxSize.height\n  } else if (edges.bottom) {\n    state.options.inner.bottom = rect.top + minSize.height\n    state.options.outer.bottom = rect.top + maxSize.height\n  }\n  if (edges.left) {\n    state.options.inner.left = rect.right - minSize.width\n    state.options.outer.left = rect.right - maxSize.width\n  } else if (edges.right) {\n    state.options.inner.right = rect.left + minSize.width\n    state.options.outer.right = rect.left + maxSize.width\n  }\n\n  restrictEdges.set(arg)\n\n  state.options = options\n}\n\nconst defaults: RestrictSizeOptions = {\n  min: null,\n  max: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst restrictSize = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(restrictSize, 'restrictSize')\nexport { restrictSize }\n", "import type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName, Point, RectResolvable, Element } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { resolveRectLike, rectToXY } from '@interactjs/utils/rect'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierState } from '../types'\n\nexport interface Offset {\n  x: number\n  y: number\n  index: number\n  relativePoint?: Point | null\n}\n\nexport interface SnapPosition {\n  x?: number\n  y?: number\n  range?: number\n  offset?: Offset\n  [index: string]: any\n}\n\nexport type SnapFunction = (\n  x: number,\n  y: number,\n  interaction: InteractionProxy<ActionName>,\n  offset: Offset,\n  index: number,\n) => SnapPosition\nexport type SnapTarget = SnapPosition | SnapFunction\nexport interface SnapOptions {\n  targets: SnapTarget[] | null\n  // target range\n  range: number\n  // self points for snapping. [0,0] = top left, [1,1] = bottom right\n  relativePoints: Point[] | null\n  // startCoords = offset snapping from drag start page position\n  offset: Point | RectResolvable<[Interaction]> | 'startCoords' | null\n  offsetWithOrigin?: boolean\n  origin: RectResolvable<[Element]> | Point | null\n  endOnly?: boolean\n  enabled?: boolean\n}\n\nexport type SnapState = ModifierState<\nSnapOptions,\n{\n  offsets?: Offset[]\n  closest?: any\n  targetFields?: string[][]\n}\n>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { interaction, interactable, element, rect, state, startOffset } = arg\n  const { options } = state\n  const origin = options.offsetWithOrigin ? getOrigin(arg) : { x: 0, y: 0 }\n\n  let snapOffset: Point\n\n  if (options.offset === 'startCoords') {\n    snapOffset = {\n      x: interaction.coords.start.page.x,\n      y: interaction.coords.start.page.y,\n    }\n  } else {\n    const offsetRect = resolveRectLike(options.offset as any, interactable, element, [interaction])\n\n    snapOffset = rectToXY(offsetRect) || { x: 0, y: 0 }\n    snapOffset.x += origin.x\n    snapOffset.y += origin.y\n  }\n\n  const { relativePoints } = options\n\n  state.offsets =\n    rect && relativePoints && relativePoints.length\n      ? relativePoints.map((relativePoint, index) => ({\n        index,\n        relativePoint,\n        x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,\n        y: startOffset.top - rect.height * relativePoint.y + snapOffset.y,\n      }))\n      : [\n        {\n          index: 0,\n          relativePoint: null,\n          x: snapOffset.x,\n          y: snapOffset.y,\n        },\n      ]\n}\n\nfunction set (arg: ModifierArg<SnapState>) {\n  const { interaction, coords, state } = arg\n  const { options, offsets } = state\n\n  const origin = getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name)\n  const page = extend({}, coords)\n  const targets = []\n\n  if (!options.offsetWithOrigin) {\n    page.x -= origin.x\n    page.y -= origin.y\n  }\n\n  for (const offset of offsets) {\n    const relativeX = page.x - offset.x\n    const relativeY = page.y - offset.y\n\n    for (let index = 0, len = options.targets.length; index < len; index++) {\n      const snapTarget = options.targets[index]\n      let target: SnapPosition\n\n      if (is.func(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index)\n      } else {\n        target = snapTarget\n      }\n\n      if (!target) {\n        continue\n      }\n\n      targets.push({\n        x: (is.number(target.x) ? target.x : relativeX) + offset.x,\n        y: (is.number(target.y) ? target.y : relativeY) + offset.y,\n\n        range: is.number(target.range) ? target.range : options.range,\n        source: snapTarget,\n        index,\n        offset,\n      })\n    }\n  }\n\n  const closest = {\n    target: null,\n    inRange: false,\n    distance: 0,\n    range: 0,\n    delta: { x: 0, y: 0 },\n  }\n\n  for (const target of targets) {\n    const range = target.range\n    const dx = target.x - page.x\n    const dy = target.y - page.y\n    const distance = hypot(dx, dy)\n    let inRange = distance <= range\n\n    // Infinite targets count as being out of range\n    // compared to non infinite ones that are in range\n    if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n      inRange = false\n    }\n\n    if (\n      !closest.target ||\n      (inRange\n        ? // is the closest target in range?\n        closest.inRange && range !== Infinity\n          ? // the pointer is relatively deeper in this target\n          distance / range < closest.distance / closest.range\n          : // this target has Infinite range and the closest doesn't\n          (range === Infinity && closest.range !== Infinity) ||\n            // OR this target is closer that the previous closest\n            distance < closest.distance\n        : // The other is not in range and the pointer is closer to this target\n        !closest.inRange && distance < closest.distance)\n    ) {\n      closest.target = target\n      closest.distance = distance\n      closest.range = range\n      closest.inRange = inRange\n      closest.delta.x = dx\n      closest.delta.y = dy\n    }\n  }\n\n  if (closest.inRange) {\n    coords.x = closest.target.x\n    coords.y = closest.target.y\n  }\n\n  state.closest = closest\n  return closest\n}\n\nfunction getOrigin (arg: Partial<ModifierArg<SnapState>>) {\n  const { element } = arg.interaction\n  const optionsOrigin = rectToXY(resolveRectLike(arg.state.options.origin as any, null, null, [element]))\n  const origin = optionsOrigin || getOriginXY(arg.interactable, element, arg.interaction.prepared.name)\n\n  return origin\n}\n\nconst defaults: SnapOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  offsetWithOrigin: true,\n  origin: null,\n  relativePoints: null,\n  endOnly: false,\n  enabled: false,\n}\nconst snap = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snap, 'snap')\nexport { snap }\n", "// This module allows snapping of the size of targets during resize\n// interactions.\n\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg } from '../types'\n\nimport type { SnapOptions, SnapState } from './pointer'\nimport { snap } from './pointer'\n\nexport type SnapSizeOptions = Pick<SnapOptions, 'targets' | 'offset' | 'endOnly' | 'range' | 'enabled'>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { state, edges } = arg\n  const { options } = state\n\n  if (!edges) {\n    return null\n  }\n\n  arg.state = {\n    options: {\n      targets: null,\n      relativePoints: [\n        {\n          x: edges.left ? 0 : 1,\n          y: edges.top ? 0 : 1,\n        },\n      ],\n      offset: options.offset || 'self',\n      origin: { x: 0, y: 0 },\n      range: options.range,\n    },\n  }\n\n  state.targetFields = state.targetFields || [\n    ['width', 'height'],\n    ['x', 'y'],\n  ]\n\n  snap.start(arg)\n  state.offsets = arg.state.offsets\n\n  arg.state = state\n}\n\nfunction set (arg) {\n  const { interaction, state, coords } = arg\n  const { options, offsets } = state\n  const relative = {\n    x: coords.x - offsets[0].x,\n    y: coords.y - offsets[0].y,\n  }\n\n  state.options = extend({}, options)\n  state.options.targets = []\n\n  for (const snapTarget of options.targets || []) {\n    let target\n\n    if (is.func(snapTarget)) {\n      target = snapTarget(relative.x, relative.y, interaction)\n    } else {\n      target = snapTarget\n    }\n\n    if (!target) {\n      continue\n    }\n\n    for (const [xField, yField] of state.targetFields) {\n      if (xField in target || yField in target) {\n        target.x = target[xField]\n        target.y = target[yField]\n\n        break\n      }\n    }\n\n    state.options.targets.push(target)\n  }\n\n  const returnValue = snap.set(arg)\n\n  state.options = options\n\n  return returnValue\n}\n\nconst defaults: SnapSizeOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  endOnly: false,\n  enabled: false,\n}\n\nconst snapSize = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snapSize, 'snapSize')\nexport { snapSize }\n", "/**\n * @module modifiers/snapEdges\n *\n * @description\n * WOW> This module allows snapping of the edges of targets during resize\n * interactions.\n *\n * ```js\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [interact.snappers.grid({ x: 100, y: 50 })],\n *   },\n * })\n *\n * interact(target).resizable({\n *   snapEdges: {\n *     targets: [\n *       interact.snappers.grid({\n *        top: 50,\n *        left: 50,\n *        bottom: 100,\n *        right: 100,\n *       }),\n *     ],\n *   },\n * })\n * ```\n */\n\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierModule } from '../types'\n\nimport type { SnapOptions, SnapState } from './pointer'\nimport { snapSize } from './size'\n\nexport type SnapEdgesOptions = Pick<SnapOptions, 'targets' | 'range' | 'offset' | 'endOnly' | 'enabled'>\n\nfunction start (arg: ModifierArg<SnapState>) {\n  const { edges } = arg\n\n  if (!edges) {\n    return null\n  }\n\n  arg.state.targetFields = arg.state.targetFields || [\n    [edges.left ? 'left' : 'right', edges.top ? 'top' : 'bottom'],\n  ]\n\n  return snapSize.start(arg)\n}\n\nconst snapEdges: ModifierModule<SnapEdgesOptions, SnapState, ReturnType<typeof snapSize.set>> = {\n  start,\n  set: snapSize.set,\n  defaults: extend(clone(snapSize.defaults), {\n    targets: null,\n    range: null,\n    offset: { x: 0, y: 0 },\n  } as const),\n}\n\nexport default makeModifier(snapEdges, 'snapEdges')\nexport { snapEdges }\n", "/* eslint-disable n/no-extraneous-import, import/no-unresolved */\nimport aspectRatio from './aspectRatio'\nimport avoid from './avoid/avoid'\nimport restrictEdges from './restrict/edges'\nimport restrict from './restrict/pointer'\nimport restrictRect from './restrict/rect'\nimport restrictSize from './restrict/size'\nimport rubberband from './rubberband/rubberband'\nimport snapEdges from './snap/edges'\nimport snap from './snap/pointer'\nimport snapSize from './snap/size'\nimport spring from './spring/spring'\nimport transform from './transform/transform'\n\nexport default {\n  aspectRatio,\n  restrictEdges,\n  restrict,\n  restrictRect,\n  restrictSize,\n  snapEdges,\n  snap,\n  snapSize,\n\n  spring,\n  avoid,\n  transform,\n  rubberband,\n}\n", "import type { Plugin } from '@interactjs/core/scope'\nimport snappers from '@interactjs/snappers/plugin'\n\nimport all from './all'\nimport base from './base'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    modifiers: typeof all\n  }\n}\n\nconst modifiers: Plugin = {\n  id: 'modifiers',\n  install (scope) {\n    const { interactStatic: interact } = scope\n\n    scope.usePlugin(base)\n    scope.usePlugin(snappers)\n\n    interact.modifiers = all\n\n    // for backwrads compatibility\n    for (const type in all) {\n      const { _defaults, _methods } = all[type as keyof typeof all]\n\n      ;(_defaults as any)._methods = _methods\n      ;(scope.defaults.perAction as any)[type] = _defaults\n    }\n  },\n}\n\nexport default modifiers\n", "/* eslint-disable no-console, eol-last, import/no-duplicates,  import/no-extraneous-dependencies, import/order */\nimport '@interactjs/modifiers/plugin'\nimport interact from '@interactjs/interact/index'\nimport plugin from '@interactjs/modifiers/plugin'\ninteract.use(plugin)"],
  "mappings": "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",
  "names": ["grid", "coordFields", "filter", "xField", "yField", "gridFunc", "x", "y", "range", "limits", "left", "right", "Infinity", "top", "bottom", "offset", "result", "gridx", "Math", "round", "gridy", "max", "min", "snappersPlugin", "id", "install", "scope", "interactStatic", "interact", "snappers", "extend", "allSnappers", "createSnapGrid", "grid", "Modification", "constructor", "interaction", "states", "startOffset", "left", "right", "top", "bottom", "startDelta", "result", "endResult", "startEdges", "edges", "createResult", "start", "phase", "pageCoords", "modifierList", "getModifierList", "prepareStates", "extend", "getRectOffset", "rect", "x", "y", "arg", "fillArg", "preEnd", "startAll", "setAll", "interactable", "element", "state", "methods", "skipModifiers", "unmodifiedRect", "unmodifiedEdges", "coords", "slice", "newResult", "options", "lastModifierCoords", "returnValue", "set", "shouldDo", "rectUtils", "addEdges", "eventProps", "push", "delta", "rectDelta", "prevCoords", "prevRect", "rectChanged", "changed", "applyToInteraction", "curCoords", "cur", "startCoords", "curDelta", "coordsSet", "page", "client", "width", "height", "setAndApply", "modifiedCoords", "length", "interacting", "adjustment", "beforeEnd", "event", "doPreend", "endPosition", "move", "stop", "modifierArg", "index", "name", "restoreInteractionCoords", "modification", "coordsAndDeltas", "requireEndOnly", "enabled", "endOnly", "setStart", "copyFrom", "other", "map", "s", "clone", "destroy", "prop", "actionOptions", "prepared", "actionModifiers", "modifiers", "type", "_methods", "filter", "m", "makeModifier", "module", "name", "defaults", "methods", "start", "set", "beforeEnd", "stop", "modifier", "_options", "options", "enabled", "prop", "m", "enable", "disable", "_defaults", "_methods", "addEventModifiers", "iEvent", "interaction", "result", "modification", "modifiers", "eventProps", "modifiersBase", "id", "before", "install", "scope", "perAction", "listeners", "Modification", "arg", "coords", "page", "edges", "applyToInteraction", "ret", "setAndApply", "startEdges", "restoreInteractionCoords", "aspectRatio", "start", "arg", "state", "rect", "edges", "pageCoords", "coords", "ratio", "enabled", "options", "equalDelta", "modifiers", "width", "height", "startCoords", "extend", "startRect", "linkedEdges", "top", "left", "bottom", "right", "xIsPrimaryAxis", "sign", "edgeSign", "x", "y", "length", "subModification", "Modification", "interaction", "copyFrom", "modification", "prepareStates", "startAll", "set", "initialCoords", "aspectMethod", "setEqualDelta", "setRatio", "correctedRect", "addEdges", "result", "setAll", "prevCoords", "prevRect", "delta", "changed", "xIsCriticalAxis", "Math", "abs", "eventProps", "defaults", "newHeight", "newWidth", "makeModifier", "noop", "_defaults", "start", "rect", "startOffset", "state", "interaction", "pageCoords", "options", "elementRect", "offset", "extend", "left", "top", "right", "bottom", "restriction", "getRestrictionRect", "widthDiff", "width", "heightDiff", "height", "set", "coords", "xywhToTlbr", "x", "Math", "max", "min", "y", "value", "is", "func", "resolveRectLike", "interactable", "element", "defaults", "endOnly", "enabled", "restrict", "makeModifier", "noInner", "top", "left", "bottom", "right", "noOuter", "start", "interaction", "startOffset", "state", "options", "offset", "offsetRect", "getRestrictionRect", "coords", "page", "rectToXY", "x", "y", "set", "edges", "extend", "inner", "outer", "fixRect", "Math", "min", "max", "rect", "defaults", "edge", "endOnly", "enabled", "restrictEdges", "makeModifier", "defaults", "extend", "elementRect", "top", "left", "bottom", "right", "_", "restrict", "restrictRect", "start", "set", "makeModifier", "noMin", "width", "height", "noMax", "start", "arg", "restrictEdges", "set", "interaction", "state", "rect", "edges", "options", "minSize", "tlbrToXywh", "getRestrictionRect", "min", "coords", "maxSize", "max", "endOnly", "inner", "extend", "noInner", "outer", "noOuter", "top", "bottom", "left", "right", "defaults", "enabled", "restrictSize", "makeModifier", "start", "arg", "interaction", "interactable", "element", "rect", "state", "startOffset", "options", "origin", "offsetWithOrigin", "getOrigin", "x", "y", "snapOffset", "offset", "coords", "page", "offsetRect", "resolveRectLike", "rectToXY", "relativePoints", "offsets", "length", "map", "relativePoint", "index", "left", "width", "top", "height", "set", "getOriginXY", "prepared", "name", "extend", "targets", "relativeX", "relativeY", "len", "snapTarget", "target", "is", "func", "_proxy", "push", "number", "range", "source", "closest", "inRange", "distance", "delta", "dx", "dy", "hypot", "Infinity", "optionsOrigin", "defaults", "endOnly", "enabled", "snap", "pointer_default", "makeModifier", "start", "arg", "state", "edges", "options", "targets", "relativePoints", "x", "left", "y", "top", "offset", "origin", "range", "targetFields", "snap", "offsets", "set", "interaction", "coords", "relative", "extend", "snapTarget", "target", "is", "func", "xField", "yField", "push", "returnValue", "defaults", "Infinity", "endOnly", "enabled", "snapSize", "size_default", "makeModifier", "start", "arg", "edges", "state", "targetFields", "left", "top", "snapSize", "snapEdges", "set", "defaults", "extend", "clone", "targets", "range", "offset", "x", "y", "edges_default", "makeModifier", "aspectRatio", "restrictEdges", "restrict", "restrictRect", "restrictSize", "snapEdges", "snap", "snapSize", "spring", "avoid", "transform", "rubberband", "modifiers", "id", "install", "scope", "interactStatic", "interact", "usePlugin", "base", "snappers", "all", "type", "_defaults", "_methods", "defaults", "perAction", "plugin_default", "interact", "use", "plugin"]
}
