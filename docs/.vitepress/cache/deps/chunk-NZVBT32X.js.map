{
  "version": 3,
  "sources": ["../../../../node_modules/@interactjs/utils/domObjects.ts", "../../../../node_modules/@interactjs/utils/isWindow.ts", "../../../../node_modules/@interactjs/utils/window.ts", "../../../../node_modules/@interactjs/utils/is.ts", "../../../../node_modules/@interactjs/utils/browser.ts", "../../../../node_modules/@interactjs/utils/arr.ts", "../../../../node_modules/@interactjs/utils/clone.ts", "../../../../node_modules/@interactjs/utils/extend.ts", "../../../../node_modules/@interactjs/utils/raf.ts", "../../../../node_modules/@interactjs/utils/normalizeListeners.ts", "../../../../node_modules/@interactjs/core/Eventable.ts", "../../../../node_modules/@interactjs/utils/domUtils.ts", "../../../../node_modules/@interactjs/utils/rect.ts", "../../../../node_modules/@interactjs/utils/getOriginXY.ts", "../../../../node_modules/@interactjs/utils/hypot.ts", "../../../../node_modules/@interactjs/core/BaseEvent.ts", "../../../../node_modules/@interactjs/core/options.ts", "../../../../node_modules/@interactjs/core/InteractEvent.ts", "../../../../node_modules/@interactjs/utils/misc.ts", "../../../../node_modules/@interactjs/utils/pointerExtend.ts", "../../../../node_modules/@interactjs/utils/pointerUtils.ts", "../../../../node_modules/@interactjs/core/isNonNativeEvent.ts", "../../../../node_modules/@interactjs/core/InteractStatic.ts", "../../../../node_modules/@interactjs/core/Interactable.ts", "../../../../node_modules/@interactjs/core/InteractableSet.ts", "../../../../node_modules/@interactjs/core/events.ts", "../../../../node_modules/@interactjs/core/PointerInfo.ts", "../../../../node_modules/@interactjs/core/Interaction.ts", "../../../../node_modules/@interactjs/core/interactablePreventDefault.ts", "../../../../node_modules/@interactjs/core/interactionFinder.ts", "../../../../node_modules/@interactjs/core/interactions.ts", "../../../../node_modules/@interactjs/core/scope.ts", "../../../../node_modules/@interactjs/interact/index.ts"],
  "sourcesContent": ["const domObjects: {\n  init: any\n  document: Document\n  DocumentFragment: typeof DocumentFragment\n  SVGElement: typeof SVGElement\n  SVGSVGElement: typeof SVGSVGElement\n  SVGElementInstance: any\n  Element: typeof Element\n  HTMLElement: typeof HTMLElement\n  Event: typeof Event\n  Touch: typeof Touch\n  PointerEvent: typeof PointerEvent\n} = {\n  init,\n  document: null,\n  DocumentFragment: null,\n  SVGElement: null,\n  SVGSVGElement: null,\n  SVGElementInstance: null,\n  Element: null,\n  HTMLElement: null,\n  Event: null,\n  Touch: null,\n  PointerEvent: null,\n}\n\nfunction blank () {}\n\nexport default domObjects\n\nfunction init (window: Window) {\n  const win = window as any\n\n  domObjects.document = win.document\n  domObjects.DocumentFragment = win.DocumentFragment || blank\n  domObjects.SVGElement = win.SVGElement || blank\n  domObjects.SVGSVGElement = win.SVGSVGElement || blank\n  domObjects.SVGElementInstance = win.SVGElementInstance || blank\n  domObjects.Element = win.Element || blank\n  domObjects.HTMLElement = win.HTMLElement || domObjects.Element\n\n  domObjects.Event = win.Event\n  domObjects.Touch = win.Touch || blank\n  domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent\n}\n", "export default (thing: any) => !!(thing && thing.Window) && thing instanceof thing.Window\n", "import isWindow from './isWindow'\n\nexport let realWindow = undefined as Window\n\nlet win = undefined as Window\nexport { win as window }\n\nexport function init (window: Window & { wrap?: (...args: any[]) => any }) {\n  // get wrapped window if using Shadow DOM polyfill\n\n  realWindow = window\n\n  // create a TextNode\n  const el = window.document.createTextNode('')\n\n  // check if it's wrapped by a polyfill\n  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {\n    // use wrapped window\n    window = window.wrap(window)\n  }\n\n  win = window\n}\n\nif (typeof window !== 'undefined' && !!window) {\n  init(window)\n}\n\nexport function getWindow (node: any) {\n  if (isWindow(node)) {\n    return node\n  }\n\n  const rootNode = node.ownerDocument || node\n\n  return rootNode.defaultView || win.window\n}\n", "import isWindow from './isWindow'\nimport * as win from './window'\n\nconst window = (thing: any): thing is Window => thing === win.window || isWindow(thing)\n\nconst docFrag = (thing: any): thing is DocumentFragment => object(thing) && thing.nodeType === 11\n\nconst object = (thing: any): thing is { [index: string]: any } => !!thing && typeof thing === 'object'\n\nconst func = (thing: any): thing is (...args: any[]) => any => typeof thing === 'function'\n\nconst number = (thing: any): thing is number => typeof thing === 'number'\n\nconst bool = (thing: any): thing is boolean => typeof thing === 'boolean'\n\nconst string = (thing: any): thing is string => typeof thing === 'string'\n\nconst element = (thing: any): thing is HTMLElement | SVGElement => {\n  if (!thing || typeof thing !== 'object') {\n    return false\n  }\n\n  const _window = win.getWindow(thing) || win.window\n\n  return /object|function/.test(typeof Element)\n    ? thing instanceof Element || thing instanceof _window.Element\n    : thing.nodeType === 1 && typeof thing.nodeName === 'string'\n}\n\nconst plainObject: typeof object = (thing: any): thing is { [index: string]: any } =>\n  object(thing) && !!thing.constructor && /function Object\\b/.test(thing.constructor.toString())\n\nconst array = <T extends unknown>(thing: any): thing is T[] =>\n  object(thing) && typeof thing.length !== 'undefined' && func(thing.splice)\n\nexport default {\n  window,\n  docFrag,\n  object,\n  func,\n  number,\n  bool,\n  string,\n  element,\n  plainObject,\n  array,\n}\n", "import domObjects from './domObjects'\nimport is from './is'\n\nconst browser = {\n  init,\n  supportsTouch: null as boolean,\n  supportsPointerEvent: null as boolean,\n  isIOS7: null as boolean,\n  isIOS: null as boolean,\n  isIe9: null as boolean,\n  isOperaMobile: null as boolean,\n  prefixedMatchesSelector: null as 'matches',\n  pEventTypes: null as {\n    up: string\n    down: string\n    over: string\n    out: string\n    move: string\n    cancel: string\n  },\n  wheelEvent: null as string,\n}\n\nfunction init (window: any) {\n  const Element = domObjects.Element\n  const navigator: Partial<Navigator> = window.navigator || {}\n\n  // Does the browser support touch input?\n  browser.supportsTouch =\n    'ontouchstart' in window ||\n    (is.func(window.DocumentTouch) && domObjects.document instanceof window.DocumentTouch)\n\n  // Does the browser support PointerEvents\n  // https://github.com/taye/interact.js/issues/703#issuecomment-471570492\n  browser.supportsPointerEvent = (navigator as any).pointerEnabled !== false && !!domObjects.PointerEvent\n\n  browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform)\n\n  // scrolling doesn't change the result of getClientRects on iOS 7\n  browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion)\n\n  browser.isIe9 = /MSIE 9/.test(navigator.userAgent)\n\n  // Opera Mobile must be handled differently\n  browser.isOperaMobile =\n    navigator.appName === 'Opera' && browser.supportsTouch && /Presto/.test(navigator.userAgent)\n\n  // prefix matchesSelector\n  browser.prefixedMatchesSelector = (\n    'matches' in Element.prototype\n      ? 'matches'\n      : 'webkitMatchesSelector' in Element.prototype\n        ? 'webkitMatchesSelector'\n        : 'mozMatchesSelector' in Element.prototype\n          ? 'mozMatchesSelector'\n          : 'oMatchesSelector' in Element.prototype\n            ? 'oMatchesSelector'\n            : 'msMatchesSelector'\n  ) as 'matches'\n\n  browser.pEventTypes = browser.supportsPointerEvent\n    ? domObjects.PointerEvent === window.MSPointerEvent\n      ? {\n        up: 'MSPointerUp',\n        down: 'MSPointerDown',\n        over: 'mouseover',\n        out: 'mouseout',\n        move: 'MSPointerMove',\n        cancel: 'MSPointerCancel',\n      }\n      : {\n        up: 'pointerup',\n        down: 'pointerdown',\n        over: 'pointerover',\n        out: 'pointerout',\n        move: 'pointermove',\n        cancel: 'pointercancel',\n      }\n    : null\n\n  // because Webkit and Opera still use 'mousewheel' event type\n  browser.wheelEvent = domObjects.document && 'onmousewheel' in domObjects.document ? 'mousewheel' : 'wheel'\n}\n\nexport default browser\n", "type Filter<T> = (element: T, index: number, array: T[]) => boolean\n\nexport const contains = <T>(array: T[], target: T) => array.indexOf(target) !== -1\n\nexport const remove = <T>(array: T[], target: T) => array.splice(array.indexOf(target), 1)\n\nexport const merge = <T, U>(target: Array<T | U>, source: U[]) => {\n  for (const item of source) {\n    target.push(item)\n  }\n\n  return target\n}\n\nexport const from = <T = any>(source: ArrayLike<T>) => merge([] as T[], source as T[])\n\nexport const findIndex = <T>(array: T[], func: Filter<T>) => {\n  for (let i = 0; i < array.length; i++) {\n    if (func(array[i], i, array)) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nexport const find = <T = any>(array: T[], func: Filter<T>) => array[findIndex(array, func)]\n", "import * as arr from './arr'\nimport is from './is'\n\n// tslint:disable-next-line ban-types\nexport default function clone<T extends Object> (source: T): Partial<T> {\n  const dest = {} as Partial<T>\n\n  for (const prop in source) {\n    const value = source[prop]\n\n    if (is.plainObject(value)) {\n      dest[prop] = clone(value) as any\n    } else if (is.array(value)) {\n      dest[prop] = arr.from(value) as typeof value\n    } else {\n      dest[prop] = value\n    }\n  }\n\n  return dest\n}\n", "export default function extend<T, U extends object> (dest: U & Partial<T>, source: T): T & U {\n  for (const prop in source) {\n    ;(dest as unknown as T)[prop] = source[prop]\n  }\n\n  const ret = dest as T & U\n\n  return ret\n}\n", "let lastTime = 0\nlet request: typeof requestAnimationFrame\nlet cancel: typeof cancelAnimationFrame\n\nfunction init (global: Window | typeof globalThis) {\n  request = global.requestAnimationFrame\n  cancel = global.cancelAnimationFrame\n\n  if (!request) {\n    const vendors = ['ms', 'moz', 'webkit', 'o']\n\n    for (const vendor of vendors) {\n      request = global[`${vendor}RequestAnimationFrame` as 'requestAnimationFrame']\n      cancel =\n        global[`${vendor}CancelAnimationFrame` as 'cancelAnimationFrame'] ||\n        global[`${vendor}CancelRequestAnimationFrame` as 'cancelAnimationFrame']\n    }\n  }\n\n  request = request && request.bind(global)\n  cancel = cancel && cancel.bind(global)\n\n  if (!request) {\n    request = (callback) => {\n      const currTime = Date.now()\n      const timeToCall = Math.max(0, 16 - (currTime - lastTime))\n      const token = global.setTimeout(() => {\n        // eslint-disable-next-line n/no-callback-literal\n        callback(currTime + timeToCall)\n      }, timeToCall)\n\n      lastTime = currTime + timeToCall\n      return token as any\n    }\n\n    cancel = (token) => clearTimeout(token)\n  }\n}\n\nexport default {\n  request: (callback: FrameRequestCallback) => request(callback),\n  cancel: (token: number) => cancel(token),\n  init,\n}\n", "import type { EventTypes, Listener, ListenersArg } from '@interactjs/core/types'\n\nimport extend from './extend'\nimport is from './is'\n\nexport interface NormalizedListeners {\n  [type: string]: Listener[]\n}\n\nexport default function normalize (\n  type: EventTypes,\n  listeners?: ListenersArg | ListenersArg[],\n  result?: NormalizedListeners,\n): NormalizedListeners {\n  result = result || {}\n\n  if (is.string(type) && type.search(' ') !== -1) {\n    type = split(type)\n  }\n\n  if (is.array(type)) {\n    return type.reduce<NormalizedListeners>((acc, t) => extend(acc, normalize(t, listeners, result)), result)\n  }\n\n  // ({ type: fn }) -> ('', { type: fn })\n  if (is.object(type)) {\n    listeners = type\n    type = ''\n  }\n\n  if (is.func(listeners)) {\n    result[type] = result[type] || []\n    result[type].push(listeners)\n  } else if (is.array(listeners)) {\n    for (const l of listeners) {\n      normalize(type, l, result)\n    }\n  } else if (is.object(listeners)) {\n    for (const prefix in listeners) {\n      const combinedTypes = split(prefix).map((p) => `${type}${p}`)\n\n      normalize(combinedTypes, listeners[prefix], result)\n    }\n  }\n\n  return result as NormalizedListeners\n}\n\nfunction split (type: string) {\n  return type.trim().split(/ +/)\n}\n", "import type { Listener, ListenersArg, Rect } from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport type { NormalizedListeners } from '@interactjs/utils/normalizeListeners'\nimport normalize from '@interactjs/utils/normalizeListeners'\n\nfunction fireUntilImmediateStopped (event: any, listeners: Listener[]) {\n  for (const listener of listeners) {\n    if (event.immediatePropagationStopped) {\n      break\n    }\n\n    listener(event)\n  }\n}\n\nexport class Eventable {\n  options: any\n  types: NormalizedListeners = {}\n  propagationStopped = false\n  immediatePropagationStopped = false\n  global: any\n\n  constructor (options?: { [index: string]: any }) {\n    this.options = extend({}, options || {})\n  }\n\n  fire<T extends { type: string, propagationStopped?: boolean }> (event: T) {\n    let listeners: Listener[]\n    const global = this.global\n\n    // Interactable#on() listeners\n    // tslint:disable no-conditional-assignment\n    if ((listeners = this.types[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n\n    // interact.on() listeners\n    if (!event.propagationStopped && global && (listeners = global[event.type])) {\n      fireUntilImmediateStopped(event, listeners)\n    }\n  }\n\n  on (type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      this.types[type] = arr.merge(this.types[type] || [], listeners[type])\n    }\n  }\n\n  off (type: string, listener: ListenersArg) {\n    const listeners = normalize(type, listener)\n\n    for (type in listeners) {\n      const eventList = this.types[type]\n\n      if (!eventList || !eventList.length) {\n        continue\n      }\n\n      for (const subListener of listeners[type]) {\n        const index = eventList.indexOf(subListener)\n\n        if (index !== -1) {\n          eventList.splice(index, 1)\n        }\n      }\n    }\n  }\n\n  getRect (_element: Element): Rect {\n    return null\n  }\n}\n", "import type { Rect, Target, Element } from '@interactjs/core/types'\n\nimport browser from './browser'\nimport domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nexport function nodeContains (parent: Node, child: Node) {\n  if (parent.contains) {\n    return parent.contains(child as Node)\n  }\n\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = (child as Node).parentNode\n  }\n\n  return false\n}\n\nexport function closest (element: Node, selector: string) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return element\n    }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode (node: Node | Document) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) && is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector (element: Element, selector: string) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\nconst getParent = (el: Node | Document | ShadowRoot) => el.parentNode || (el as ShadowRoot).host\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement (elements: Element[] | NodeListOf<globalThis.Element>) {\n  let deepestNodeParents: Node[] = []\n  let deepestNodeIndex: number\n\n  for (let i = 0; i < elements.length; i++) {\n    const currentNode = elements[i]\n    const deepestNode: Node = elements[deepestNodeIndex]\n\n    // node may appear in elements array multiple times\n    if (!currentNode || i === deepestNodeIndex) {\n      continue\n    }\n\n    if (!deepestNode) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    const currentNodeParent = getParent(currentNode)\n    const deepestNodeParent = getParent(deepestNode)\n\n    // check if the deepest or current are document.documentElement/rootElement\n    // - if the current node is, do nothing and continue\n    if (currentNodeParent === currentNode.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current node and continue to next\n    else if (deepestNodeParent === currentNode.ownerDocument) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    // compare zIndex of siblings\n    if (currentNodeParent === deepestNodeParent) {\n      if (zIndexIsHigherThan(currentNode, deepestNode)) {\n        deepestNodeIndex = i\n      }\n\n      continue\n    }\n\n    // populate the ancestry array for the latest deepest node\n    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode)\n\n    let ancestryStart: Node\n\n    // if the deepest node is an HTMLElement and the current node is a non root svg element\n    if (\n      deepestNode instanceof domObjects.HTMLElement &&\n      currentNode instanceof domObjects.SVGElement &&\n      !(currentNode instanceof domObjects.SVGSVGElement)\n    ) {\n      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?\n      if (currentNode === deepestNodeParent) {\n        continue\n      }\n\n      ancestryStart = currentNode.ownerSVGElement\n    } else {\n      ancestryStart = currentNode\n    }\n\n    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument)\n    let commonIndex = 0\n\n    // get (position of closest common ancestor) + 1\n    while (\n      currentNodeParents[commonIndex] &&\n      currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]\n    ) {\n      commonIndex++\n    }\n\n    const parents = [\n      currentNodeParents[commonIndex - 1],\n      currentNodeParents[commonIndex],\n      deepestNodeParents[commonIndex],\n    ]\n\n    if (parents[0]) {\n      let child = parents[0].lastChild\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestNodeIndex = i\n          deepestNodeParents = currentNodeParents\n\n          break\n        } else if (child === parents[2]) {\n          break\n        }\n\n        child = child.previousSibling\n      }\n    }\n  }\n\n  return deepestNodeIndex\n}\n\nfunction getNodeParents (node: Node, limit?: Node) {\n  const parents: Node[] = []\n  let parent: Node = node\n  let parentParent: Node\n\n  while ((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument) {\n    parents.unshift(parent)\n    parent = parentParent\n  }\n\n  return parents\n}\n\nfunction zIndexIsHigherThan (higherNode: Node, lowerNode: Node) {\n  const higherIndex = parseInt(win.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0\n  const lowerIndex = parseInt(win.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0\n\n  return higherIndex >= lowerIndex\n}\n\nexport function matchesUpTo (element: Element, selector: string, limit: Node) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element) as Element\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement (element: Element) {\n  return (element as any).correspondingUseElement || element\n}\n\nexport function getScrollXY (relevantWindow?: Window) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect (element: Element): Required<Rect> {\n  const clientRect =\n    element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0]\n\n  return (\n    clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    }\n  )\n}\n\nexport function getElementRect (element: Element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 && clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left += scroll.x\n    clientRect.right += scroll.x\n    clientRect.top += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath (node: Node | Document) {\n  const path = []\n\n  while (node) {\n    path.push(node)\n    node = parentNode(node)\n  }\n\n  return path\n}\n\nexport function trySelector (value: Target) {\n  if (!is.string(value)) {\n    return false\n  }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n", "import type {\n  HasGetRect,\n  RectResolvable,\n  Rect,\n  Element,\n  Point,\n  FullRect,\n  EdgeOptions,\n} from '@interactjs/core/types'\n\nimport { closest, getElementRect, parentNode } from './domUtils'\nimport extend from './extend'\nimport is from './is'\n\nexport function getStringOptionResult (value: any, target: HasGetRect, element: Node) {\n  if (value === 'parent') {\n    return parentNode(element)\n  }\n\n  if (value === 'self') {\n    return target.getRect(element as Element)\n  }\n\n  return closest(element, value)\n}\n\nexport function resolveRectLike<T extends any[]> (\n  value: RectResolvable<T>,\n  target?: HasGetRect,\n  element?: Node,\n  functionArgs?: T,\n) {\n  let returnValue: any = value\n  if (is.string(returnValue)) {\n    returnValue = getStringOptionResult(returnValue, target, element)\n  } else if (is.func(returnValue)) {\n    returnValue = returnValue(...functionArgs)\n  }\n\n  if (is.element(returnValue)) {\n    returnValue = getElementRect(returnValue)\n  }\n\n  return returnValue as Rect\n}\n\nexport function rectToXY (rect: Rect | Point) {\n  return (\n    rect && {\n      x: 'x' in rect ? rect.x : rect.left,\n      y: 'y' in rect ? rect.y : rect.top,\n    }\n  )\n}\n\nexport function xywhToTlbr<T extends Partial<Rect & Point>> (rect: T) {\n  if (rect && !('left' in rect && 'top' in rect)) {\n    rect = extend({}, rect)\n\n    rect.left = rect.x || 0\n    rect.top = rect.y || 0\n    rect.right = rect.right || rect.left + rect.width\n    rect.bottom = rect.bottom || rect.top + rect.height\n  }\n\n  return rect as Rect & T\n}\n\nexport function tlbrToXywh (rect: Rect & Partial<Point>) {\n  if (rect && !('x' in rect && 'y' in rect)) {\n    rect = extend({}, rect)\n\n    rect.x = rect.left || 0\n    rect.y = rect.top || 0\n    rect.width = rect.width || (rect.right || 0) - rect.x\n    rect.height = rect.height || (rect.bottom || 0) - rect.y\n  }\n\n  return rect as FullRect & Point\n}\n\nexport function addEdges (edges: EdgeOptions, rect: Rect, delta: Point) {\n  if (edges.left) {\n    rect.left += delta.x\n  }\n  if (edges.right) {\n    rect.right += delta.x\n  }\n  if (edges.top) {\n    rect.top += delta.y\n  }\n  if (edges.bottom) {\n    rect.bottom += delta.y\n  }\n\n  rect.width = rect.right - rect.left\n  rect.height = rect.bottom - rect.top\n}\n", "import type { PerActionDefaults } from '@interactjs/core/options'\nimport type { ActionName, HasGetRect } from '@interactjs/core/types'\n\nimport { rectToXY, resolveRectLike } from './rect'\n\nexport default function (\n  target: HasGetRect & { options: PerActionDefaults },\n  element: Node,\n  actionName?: ActionName,\n) {\n  const actionOptions = (target.options as any)[actionName]\n  const actionOrigin = actionOptions && actionOptions.origin\n  const origin = actionOrigin || target.options.origin\n\n  const originRect = resolveRectLike(origin, target, element, [target && element])\n\n  return rectToXY(originRect) || { x: 0, y: 0 }\n}\n", "export default (x: number, y: number) => Math.sqrt(x * x + y * y)\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName } from '@interactjs/core/types'\n\nexport class BaseEvent<T extends ActionName | null = never> {\n  declare type: string\n  declare target: EventTarget\n  declare currentTarget: Node\n  declare interactable: Interactable\n  declare _interaction: Interaction<T>\n  declare timeStamp: number\n  immediatePropagationStopped = false\n  propagationStopped = false\n\n  constructor (interaction: Interaction<T>) {\n    this._interaction = interaction\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface BaseEvent<T extends ActionName> {\n  interaction: InteractionProxy<T>\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperty(BaseEvent.prototype, 'interaction', {\n  get (this: BaseEvent) {\n    return this._interaction._proxy\n  },\n  set (this: BaseEvent) {},\n})\n", "import type { Point, Listeners, OrBoolean, Element } from '@interactjs/core/types'\n\nexport interface Defaults {\n  base: BaseDefaults\n  perAction: PerActionDefaults\n  actions: ActionDefaults\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface ActionDefaults {}\n\nexport interface BaseDefaults {\n  preventDefault?: 'auto' | 'never' | string\n  deltaSource?: 'page' | 'client'\n  context?: Node\n}\n\nexport interface PerActionDefaults {\n  enabled?: boolean\n  origin?: Point | string | Element\n  listeners?: Listeners\n  allowFrom?: string | Element\n  ignoreFrom?: string | Element\n}\n\nexport type Options = Partial<BaseDefaults> &\nPartial<PerActionDefaults> & {\n  [P in keyof ActionDefaults]?: Partial<ActionDefaults[P]>\n}\n\nexport interface OptionsArg extends BaseDefaults, OrBoolean<Partial<ActionDefaults>> {}\n\nexport const defaults: Defaults = {\n  base: {\n    preventDefault: 'auto',\n    deltaSource: 'page',\n  },\n\n  perAction: {\n    enabled: false,\n    origin: { x: 0, y: 0 },\n  },\n\n  actions: {} as ActionDefaults,\n}\n", "import type { Point, FullRect, PointerEventType, Element } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\n\nimport { BaseEvent } from './BaseEvent'\nimport type { Interaction } from './Interaction'\nimport { defaults } from './options'\nimport type { ActionName } from './types'\n\nexport type EventPhase = keyof PhaseMap\n\nexport interface PhaseMap {\n  start: true\n  move: true\n  end: true\n}\n\n// defined outside of class definition to avoid assignment of undefined during\n// construction\nexport interface InteractEvent {\n  pageX: number\n  pageY: number\n\n  clientX: number\n  clientY: number\n\n  dx: number\n  dy: number\n\n  velocityX: number\n  velocityY: number\n}\n\nexport class InteractEvent<\n  T extends ActionName = never,\n  P extends EventPhase = EventPhase,\n> extends BaseEvent<T> {\n  declare target: Element\n  declare currentTarget: Element\n  relatedTarget: Element | null = null\n  screenX?: number\n  screenY?: number\n  button: number\n  buttons: number\n  ctrlKey: boolean\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  page: Point\n  client: Point\n  delta: Point\n  rect: FullRect\n  x0: number\n  y0: number\n  t0: number\n  dt: number\n  duration: number\n  clientX0: number\n  clientY0: number\n  velocity: Point\n  speed: number\n  swipe: ReturnType<InteractEvent<T>['getSwipe']>\n  // resize\n  axes?: 'x' | 'y' | 'xy'\n  preEnd?: boolean\n\n  /** */\n  constructor (\n    interaction: Interaction<T>,\n    event: PointerEventType,\n    actionName: T,\n    phase: P,\n    element: Element,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    super(interaction)\n\n    element = element || interaction.element\n\n    const target = interaction.interactable\n    const deltaSource = (((target && target.options) || defaults) as any).deltaSource as 'page' | 'client'\n    const origin = getOriginXY(target, element, actionName)\n    const starting = phase === 'start'\n    const ending = phase === 'end'\n    const prevEvent = starting ? this : interaction.prevEvent\n    const coords = starting\n      ? interaction.coords.start\n      : ending\n        ? { page: prevEvent.page, client: prevEvent.client, timeStamp: interaction.coords.cur.timeStamp }\n        : interaction.coords.cur\n\n    this.page = extend({}, coords.page)\n    this.client = extend({}, coords.client)\n    this.rect = extend({}, interaction.rect)\n    this.timeStamp = coords.timeStamp\n\n    if (!ending) {\n      this.page.x -= origin.x\n      this.page.y -= origin.y\n\n      this.client.x -= origin.x\n      this.client.y -= origin.y\n    }\n\n    this.ctrlKey = event.ctrlKey\n    this.altKey = event.altKey\n    this.shiftKey = event.shiftKey\n    this.metaKey = event.metaKey\n    this.button = (event as MouseEvent).button\n    this.buttons = (event as MouseEvent).buttons\n    this.target = element\n    this.currentTarget = element\n    this.preEnd = preEnd\n    this.type = type || actionName + (phase || '')\n    this.interactable = target\n\n    this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0\n\n    this.x0 = interaction.coords.start.page.x - origin.x\n    this.y0 = interaction.coords.start.page.y - origin.y\n    this.clientX0 = interaction.coords.start.client.x - origin.x\n    this.clientY0 = interaction.coords.start.client.y - origin.y\n\n    if (starting || ending) {\n      this.delta = { x: 0, y: 0 }\n    } else {\n      this.delta = {\n        x: this[deltaSource].x - prevEvent[deltaSource].x,\n        y: this[deltaSource].y - prevEvent[deltaSource].y,\n      }\n    }\n\n    this.dt = interaction.coords.delta.timeStamp\n    this.duration = this.timeStamp - this.t0\n\n    // velocity and speed in pixels per second\n    this.velocity = extend({}, interaction.coords.velocity[deltaSource])\n    this.speed = hypot(this.velocity.x, this.velocity.y)\n\n    this.swipe = ending || phase === 'inertiastart' ? this.getSwipe() : null\n  }\n\n  getSwipe () {\n    const interaction = this._interaction\n\n    if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {\n      return null\n    }\n\n    let angle = (180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX)) / Math.PI\n    const overlap = 22.5\n\n    if (angle < 0) {\n      angle += 360\n    }\n\n    const left = 135 - overlap <= angle && angle < 225 + overlap\n    const up = 225 - overlap <= angle && angle < 315 + overlap\n\n    const right = !left && (315 - overlap <= angle || angle < 45 + overlap)\n    const down = !up && 45 - overlap <= angle && angle < 135 + overlap\n\n    return {\n      up,\n      down,\n      left,\n      right,\n      angle,\n      speed: interaction.prevEvent.speed,\n      velocity: {\n        x: interaction.prevEvent.velocityX,\n        y: interaction.prevEvent.velocityY,\n      },\n    }\n  }\n\n  preventDefault () {}\n\n  /**\n   * Don't call listeners on the remaining targets\n   */\n  stopImmediatePropagation () {\n    this.immediatePropagationStopped = this.propagationStopped = true\n  }\n\n  /**\n   * Don't call any other listeners (even on the current target)\n   */\n  stopPropagation () {\n    this.propagationStopped = true\n  }\n}\n\n// getters and setters defined here to support typescript 3.6 and below which\n// don't support getter and setters in .d.ts files\nObject.defineProperties(InteractEvent.prototype, {\n  pageX: {\n    get () {\n      return this.page.x\n    },\n    set (value) {\n      this.page.x = value\n    },\n  },\n  pageY: {\n    get () {\n      return this.page.y\n    },\n    set (value) {\n      this.page.y = value\n    },\n  },\n\n  clientX: {\n    get () {\n      return this.client.x\n    },\n    set (value) {\n      this.client.x = value\n    },\n  },\n  clientY: {\n    get () {\n      return this.client.y\n    },\n    set (value) {\n      this.client.y = value\n    },\n  },\n\n  dx: {\n    get () {\n      return this.delta.x\n    },\n    set (value) {\n      this.delta.x = value\n    },\n  },\n  dy: {\n    get () {\n      return this.delta.y\n    },\n    set (value) {\n      this.delta.y = value\n    },\n  },\n\n  velocityX: {\n    get () {\n      return this.velocity.x\n    },\n    set (value) {\n      this.velocity.x = value\n    },\n  },\n  velocityY: {\n    get () {\n      return this.velocity.y\n    },\n    set (value) {\n      this.velocity.y = value\n    },\n  },\n})\n", "import type { ActionName, ActionProps } from '@interactjs/core/types'\n\nimport { window } from './window'\n\nexport function warnOnce<T> (this: T, method: (...args: any[]) => any, message: string) {\n  let warned = false\n\n  return function (this: T) {\n    if (!warned) {\n      ;(window as any).console.warn(message)\n      warned = true\n    }\n\n    return method.apply(this, arguments)\n  }\n}\n\nexport function copyAction<T extends ActionName> (dest: ActionProps<any>, src: ActionProps<T>) {\n  dest.name = src.name\n  dest.axis = src.axis\n  dest.edges = src.edges\n\n  return dest\n}\n\nexport const sign = (n: number) => (n >= 0 ? 1 : -1)\n", "const VENDOR_PREFIXES = ['webkit', 'moz']\n\nexport default function pointerExtend<T> (dest: Partial<T & { __set?: Partial<T> }>, source: T) {\n  dest.__set ||= {} as any\n\n  for (const prop in source) {\n    // skip deprecated prefixed properties\n    if (VENDOR_PREFIXES.some((prefix) => prop.indexOf(prefix) === 0)) continue\n\n    if (typeof dest[prop] !== 'function' && prop !== '__set') {\n      Object.defineProperty(dest, prop, {\n        get () {\n          if (prop in dest.__set) return dest.__set[prop]\n\n          return (dest.__set[prop] = source[prop] as any)\n        },\n        set (value: any) {\n          dest.__set[prop] = value\n        },\n        configurable: true,\n      })\n    }\n  }\n  return dest\n}\n", "import type { InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { CoordsSetMember, PointerType, Point, PointerEventType, Element } from '@interactjs/core/types'\n\nimport browser from './browser'\nimport dom from './domObjects'\nimport * as domUtils from './domUtils'\nimport hypot from './hypot'\nimport is from './is'\nimport pointerExtend from './pointerExtend'\n\nexport function copyCoords (dest: CoordsSetMember, src: CoordsSetMember) {\n  dest.page = dest.page || ({} as any)\n  dest.page.x = src.page.x\n  dest.page.y = src.page.y\n\n  dest.client = dest.client || ({} as any)\n  dest.client.x = src.client.x\n  dest.client.y = src.client.y\n\n  dest.timeStamp = src.timeStamp\n}\n\nexport function setCoordDeltas (targetObj: CoordsSetMember, prev: CoordsSetMember, cur: CoordsSetMember) {\n  targetObj.page.x = cur.page.x - prev.page.x\n  targetObj.page.y = cur.page.y - prev.page.y\n  targetObj.client.x = cur.client.x - prev.client.x\n  targetObj.client.y = cur.client.y - prev.client.y\n  targetObj.timeStamp = cur.timeStamp - prev.timeStamp\n}\n\nexport function setCoordVelocity (targetObj: CoordsSetMember, delta: CoordsSetMember) {\n  const dt = Math.max(delta.timeStamp / 1000, 0.001)\n\n  targetObj.page.x = delta.page.x / dt\n  targetObj.page.y = delta.page.y / dt\n  targetObj.client.x = delta.client.x / dt\n  targetObj.client.y = delta.client.y / dt\n  targetObj.timeStamp = dt\n}\n\nexport function setZeroCoords (targetObj: CoordsSetMember) {\n  targetObj.page.x = 0\n  targetObj.page.y = 0\n  targetObj.client.x = 0\n  targetObj.client.y = 0\n}\n\nexport function isNativePointer (pointer: any) {\n  return pointer instanceof dom.Event || pointer instanceof dom.Touch\n}\n\n// Get specified X/Y coords for mouse or event.touches[0]\nexport function getXY (type: string, pointer: PointerType | InteractEvent, xy: Point) {\n  xy = xy || ({} as Point)\n  type = type || 'page'\n\n  xy.x = pointer[(type + 'X') as 'pageX']\n  xy.y = pointer[(type + 'Y') as 'pageY']\n\n  return xy\n}\n\nexport function getPageXY (pointer: PointerType | InteractEvent, page?: Point) {\n  page = page || { x: 0, y: 0 }\n\n  // Opera Mobile handles the viewport and scrolling oddly\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    getXY('screen', pointer, page)\n\n    page.x += window.scrollX\n    page.y += window.scrollY\n  } else {\n    getXY('page', pointer, page)\n  }\n\n  return page\n}\n\nexport function getClientXY (pointer: PointerType, client: Point) {\n  client = client || ({} as any)\n\n  if (browser.isOperaMobile && isNativePointer(pointer)) {\n    // Opera Mobile handles the viewport and scrolling oddly\n    getXY('screen', pointer, client)\n  } else {\n    getXY('client', pointer, client)\n  }\n\n  return client\n}\n\nexport function getPointerId (pointer: { pointerId?: number, identifier?: number, type?: string }) {\n  return is.number(pointer.pointerId) ? pointer.pointerId! : pointer.identifier!\n}\n\nexport function setCoords (dest: CoordsSetMember, pointers: any[], timeStamp: number) {\n  const pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0]\n\n  getPageXY(pointer, dest.page)\n  getClientXY(pointer, dest.client)\n\n  dest.timeStamp = timeStamp\n}\n\nexport function getTouchPair (event: TouchEvent | PointerType[]) {\n  const touches: PointerType[] = []\n\n  // array of touches is supplied\n  if (is.array(event)) {\n    touches[0] = event[0]\n    touches[1] = event[1]\n  }\n  // an event\n  else {\n    if (event.type === 'touchend') {\n      if (event.touches.length === 1) {\n        touches[0] = event.touches[0]\n        touches[1] = event.changedTouches[0]\n      } else if (event.touches.length === 0) {\n        touches[0] = event.changedTouches[0]\n        touches[1] = event.changedTouches[1]\n      }\n    } else {\n      touches[0] = event.touches[0]\n      touches[1] = event.touches[1]\n    }\n  }\n\n  return touches\n}\n\nexport function pointerAverage (pointers: PointerType[]) {\n  const average = {\n    pageX: 0,\n    pageY: 0,\n    clientX: 0,\n    clientY: 0,\n    screenX: 0,\n    screenY: 0,\n  }\n\n  type CoordKeys = keyof typeof average\n\n  for (const pointer of pointers) {\n    for (const prop in average) {\n      average[prop as CoordKeys] += pointer[prop as CoordKeys]\n    }\n  }\n  for (const prop in average) {\n    average[prop as CoordKeys] /= pointers.length\n  }\n\n  return average\n}\n\nexport function touchBBox (event: PointerType[]) {\n  if (!event.length) {\n    return null\n  }\n\n  const touches = getTouchPair(event)\n  const minX = Math.min(touches[0].pageX, touches[1].pageX)\n  const minY = Math.min(touches[0].pageY, touches[1].pageY)\n  const maxX = Math.max(touches[0].pageX, touches[1].pageX)\n  const maxY = Math.max(touches[0].pageY, touches[1].pageY)\n\n  return {\n    x: minX,\n    y: minY,\n    left: minX,\n    top: minY,\n    right: maxX,\n    bottom: maxY,\n    width: maxX - minX,\n    height: maxY - minY,\n  }\n}\n\nexport function touchDistance (event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n\n  const dx = touches[0][sourceX] - touches[1][sourceX]\n  const dy = touches[0][sourceY] - touches[1][sourceY]\n\n  return hypot(dx, dy)\n}\n\nexport function touchAngle (event: PointerType[] | TouchEvent, deltaSource: string) {\n  const sourceX = (deltaSource + 'X') as 'pageX'\n  const sourceY = (deltaSource + 'Y') as 'pageY'\n  const touches = getTouchPair(event)\n  const dx = touches[1][sourceX] - touches[0][sourceX]\n  const dy = touches[1][sourceY] - touches[0][sourceY]\n  const angle = (180 * Math.atan2(dy, dx)) / Math.PI\n\n  return angle\n}\n\nexport function getPointerType (pointer: { pointerType?: string, identifier?: number, type?: string }) {\n  return is.string(pointer.pointerType)\n    ? pointer.pointerType\n    : is.number(pointer.pointerType)\n      ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType]!\n      : // if the PointerEvent API isn't available, then the \"pointer\" must\n    // be either a MouseEvent, TouchEvent, or Touch object\n      /touch/.test(pointer.type || '') || pointer instanceof dom.Touch\n        ? 'touch'\n        : 'mouse'\n}\n\n// [ event.target, event.currentTarget ]\nexport function getEventTargets (event: Event) {\n  const path = is.func(event.composedPath)\n    ? (event.composedPath() as Element[])\n    : (event as unknown as { path: Element[] }).path\n\n  return [\n    domUtils.getActualElement(path ? path[0] : (event.target as Element)),\n    domUtils.getActualElement(event.currentTarget as Element),\n  ]\n}\n\nexport function newCoords (): CoordsSetMember {\n  return {\n    page: { x: 0, y: 0 },\n    client: { x: 0, y: 0 },\n    timeStamp: 0,\n  }\n}\n\nexport function coordsToEvent (coords: MockCoords) {\n  const event = {\n    coords,\n    get page () {\n      return this.coords.page\n    },\n    get client () {\n      return this.coords.client\n    },\n    get timeStamp () {\n      return this.coords.timeStamp\n    },\n    get pageX () {\n      return this.coords.page.x\n    },\n    get pageY () {\n      return this.coords.page.y\n    },\n    get clientX () {\n      return this.coords.client.x\n    },\n    get clientY () {\n      return this.coords.client.y\n    },\n    get pointerId () {\n      return this.coords.pointerId\n    },\n    get target () {\n      return this.coords.target\n    },\n    get type () {\n      return this.coords.type\n    },\n    get pointerType () {\n      return this.coords.pointerType\n    },\n    get buttons () {\n      return this.coords.buttons\n    },\n    preventDefault () {},\n  }\n\n  return event as typeof event & PointerType & PointerEventType\n}\n\nexport interface MockCoords {\n  page: Point\n  client: Point\n  timeStamp?: number\n  pointerId?: any\n  target?: any\n  type?: string\n  pointerType?: string\n  buttons?: number\n}\n\nexport { pointerExtend }\n", "import type { Actions } from '@interactjs/core/types'\n\nexport default function isNonNativeEvent (type: string, actions: Actions) {\n  if (actions.phaselessTypes[type]) {\n    return true\n  }\n\n  for (const name in actions.map) {\n    if (type.indexOf(name) === 0 && type.substr(name.length) in actions.phases) {\n      return true\n    }\n  }\n\n  return false\n}\n", "/** @module interact */\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Context, EventTypes, Listener, ListenersArg, Target } from '@interactjs/core/types'\nimport browser from '@interactjs/utils/browser'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { Interactable } from './Interactable'\nimport isNonNativeEvent from './isNonNativeEvent'\nimport type { Options } from './options'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    (target: Target, options?: Options): Interactable\n    getPointerAverage: typeof pointerUtils.pointerAverage\n    getTouchBBox: typeof pointerUtils.touchBBox\n    getTouchDistance: typeof pointerUtils.touchDistance\n    getTouchAngle: typeof pointerUtils.touchAngle\n    getElementRect: typeof domUtils.getElementRect\n    getElementClientRect: typeof domUtils.getElementClientRect\n    matchesSelector: typeof domUtils.matchesSelector\n    closest: typeof domUtils.closest\n    /** @internal */ globalEvents: any\n    version: string\n    /** @internal */ scope: Scope\n    use(\n      plugin: Plugin,\n      options?: {\n        [key: string]: any\n      },\n    ): any\n    isSet(target: Target, options?: any): boolean\n    on(type: string | EventTypes, listener: ListenersArg, options?: object): any\n    off(type: EventTypes, listener: any, options?: object): any\n    debug(): any\n    supportsTouch(): boolean\n    supportsPointerEvent(): boolean\n    stop(): any\n    pointerMoveTolerance(newValue?: number): any\n    addDocument(doc: Document, options?: object): void\n    removeDocument(doc: Document): void\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\ntype _InteractStatic = import('@interactjs/core/InteractStatic').InteractStatic\n\nexport function createInteractStatic (scope: Scope): _InteractStatic {\n  /**\n   * ```js\n   * interact('#draggable').draggable(true)\n   *\n   * var rectables = interact('rect')\n   * rectables\n   *   .gesturable(true)\n   *   .on('gesturemove', function (event) {\n   *       // ...\n   *   })\n   * ```\n   *\n   * The methods of this variable can be used to set elements as interactables\n   * and also to change various default settings.\n   *\n   * Calling it as a function and passing an element or a valid CSS selector\n   * string returns an Interactable object which has various methods to configure\n   * it.\n   *\n   * @global\n   *\n   * @param {Element | string} target The HTML or SVG Element to interact with\n   * or CSS selector\n   * @return {Interactable}\n   */\n  const interact = ((target: Target, options: Options) => {\n    let interactable = scope.interactables.get(target, options)\n\n    if (!interactable) {\n      interactable = scope.interactables.new(target, options)\n      interactable.events.global = interact.globalEvents\n    }\n\n    return interactable\n  }) as _InteractStatic\n\n  // expose the functions used to calculate multi-touch properties\n  interact.getPointerAverage = pointerUtils.pointerAverage\n  interact.getTouchBBox = pointerUtils.touchBBox\n  interact.getTouchDistance = pointerUtils.touchDistance\n  interact.getTouchAngle = pointerUtils.touchAngle\n\n  interact.getElementRect = domUtils.getElementRect\n  interact.getElementClientRect = domUtils.getElementClientRect\n  interact.matchesSelector = domUtils.matchesSelector\n  interact.closest = domUtils.closest\n\n  interact.globalEvents = {} as any\n\n  // eslint-disable-next-line no-undef\n  interact.version = process.env.npm_package_version\n  interact.scope = scope\n  /**\n   * Use a plugin\n   *\n   * @alias module:interact.use\n   *\n   */\n  interact.use = function (plugin, options) {\n    this.scope.usePlugin(plugin, options)\n\n    return this\n  }\n\n  /**\n   * Check if an element or selector has been set with the {@link interact}\n   * function\n   *\n   * @alias module:interact.isSet\n   *\n   * @param {Target} target The Element or string being searched for\n   * @param {object} options\n   * @return {boolean} Indicates if the element or CSS selector was previously\n   * passed to interact\n   */\n  interact.isSet = function (target: Target, options?: { context?: Context }): boolean {\n    return !!this.scope.interactables.get(target, options && options.context)\n  }\n\n  /**\n   * @deprecated\n   * Add a global listener for an InteractEvent or adds a DOM event to `document`\n   *\n   * @alias module:interact.on\n   *\n   * @param {string | array | object} type The types of events to listen for\n   * @param {function} listener The function event (s)\n   * @param {object | boolean} [options] object or useCapture flag for\n   * addEventListener\n   * @return {object} interact\n   */\n  interact.on = warnOnce(function on (type: string | EventTypes, listener: ListenersArg, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type as any[]) {\n        this.on(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.on(prop, (type as any)[prop], listener)\n      }\n\n      return this\n    }\n\n    // if it is an InteractEvent type, add listener to globalEvents\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      // if this type of event was never bound\n      if (!this.globalEvents[type]) {\n        this.globalEvents[type] = [listener]\n      } else {\n        this.globalEvents[type].push(listener)\n      }\n    }\n    // If non InteractEvent type, addEventListener to document\n    else {\n      this.scope.events.add(this.scope.document, type, listener as Listener, { options })\n    }\n\n    return this\n  }, 'The interact.on() method is being deprecated')\n\n  /**\n   * @deprecated\n   * Removes a global InteractEvent listener or DOM event from `document`\n   *\n   * @alias module:interact.off\n   *\n   * @param {string | array | object} type The types of events that were listened\n   * for\n   * @param {function} listener The listener function to be removed\n   * @param {object | boolean} options [options] object or useCapture flag for\n   * removeEventListener\n   * @return {object} interact\n   */\n  interact.off = warnOnce(function off (type: EventTypes, listener: any, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type) {\n        this.off(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.off(prop, type[prop], listener)\n      }\n\n      return this\n    }\n\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      let index: number\n\n      if (type in this.globalEvents && (index = this.globalEvents[type].indexOf(listener)) !== -1) {\n        this.globalEvents[type].splice(index, 1)\n      }\n    } else {\n      this.scope.events.remove(this.scope.document, type, listener, options)\n    }\n\n    return this\n  }, 'The interact.off() method is being deprecated')\n\n  interact.debug = function () {\n    return this.scope\n  }\n\n  /**\n   * @alias module:interact.supportsTouch\n   *\n   * @return {boolean} Whether or not the browser supports touch input\n   */\n  interact.supportsTouch = function () {\n    return browser.supportsTouch\n  }\n\n  /**\n   * @alias module:interact.supportsPointerEvent\n   *\n   * @return {boolean} Whether or not the browser supports PointerEvents\n   */\n  interact.supportsPointerEvent = function () {\n    return browser.supportsPointerEvent\n  }\n\n  /**\n   * Cancels all interactions (end events are not fired)\n   *\n   * @alias module:interact.stop\n   *\n   * @return {object} interact\n   */\n  interact.stop = function () {\n    for (const interaction of this.scope.interactions.list) {\n      interaction.stop()\n    }\n\n    return this\n  }\n\n  /**\n   * Returns or sets the distance the pointer must be moved before an action\n   * sequence occurs. This also affects tolerance for tap events.\n   *\n   * @alias module:interact.pointerMoveTolerance\n   *\n   * @param {number} [newValue] The movement from the start position must be greater than this value\n   * @return {interact | number}\n   */\n  interact.pointerMoveTolerance = function (newValue?: number) {\n    if (is.number(newValue)) {\n      this.scope.interactions.pointerMoveTolerance = newValue\n\n      return this\n    }\n\n    return this.scope.interactions.pointerMoveTolerance\n  }\n\n  interact.addDocument = function (doc: Document, options?: object) {\n    this.scope.addDocument(doc, options)\n  }\n\n  interact.removeDocument = function (doc: Document) {\n    this.scope.removeDocument(doc)\n  }\n\n  return interact\n}\n", "/* eslint-disable no-dupe-class-members */\nimport type { Scope } from '@interactjs/core/scope'\nimport type {\n  ActionMap,\n  ActionMethod,\n  ActionName,\n  Actions,\n  Context,\n  Element,\n  EventTypes,\n  Listeners,\n  ListenersArg,\n  OrBoolean,\n  Target,\n} from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport { getElementRect, matchesUpTo, nodeContains, trySelector } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport { getWindow } from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport isNonNativeEvent from './isNonNativeEvent'\nimport type { ActionDefaults, Defaults, OptionsArg, PerActionDefaults, Options } from './options'\n\ntype IgnoreValue = string | Element | boolean\ntype DeltaSource = 'page' | 'client'\n\n/** */\nexport class Interactable implements Partial<Eventable> {\n  /** @internal */ get _defaults (): Defaults {\n    return {\n      base: {},\n      perAction: {},\n      actions: {} as ActionDefaults,\n    }\n  }\n\n  readonly options!: Required<Options>\n  readonly _actions: Actions\n  readonly target: Target\n  readonly events = new Eventable()\n  readonly _context: Context\n  readonly _win: Window\n  readonly _doc: Document\n  readonly _scopeEvents: Scope['events']\n\n  /** @internal */ _rectChecker?: typeof Interactable.prototype.getRect\n\n  /** */\n  constructor (\n    target: Target,\n    options: any,\n    defaultContext: Document | Element,\n    scopeEvents: Scope['events'],\n  ) {\n    this._actions = options.actions\n    this.target = target\n    this._context = options.context || defaultContext\n    this._win = getWindow(trySelector(target) ? this._context : target)\n    this._doc = this._win.document\n    this._scopeEvents = scopeEvents\n\n    this.set(options)\n  }\n\n  setOnEvents (actionName: ActionName, phases: NonNullable<any>) {\n    if (is.func(phases.onstart)) {\n      this.on(`${actionName}start`, phases.onstart)\n    }\n    if (is.func(phases.onmove)) {\n      this.on(`${actionName}move`, phases.onmove)\n    }\n    if (is.func(phases.onend)) {\n      this.on(`${actionName}end`, phases.onend)\n    }\n    if (is.func(phases.oninertiastart)) {\n      this.on(`${actionName}inertiastart`, phases.oninertiastart)\n    }\n\n    return this\n  }\n\n  updatePerActionListeners (actionName: ActionName, prev: Listeners, cur: Listeners) {\n    if (is.array(prev) || is.object(prev)) {\n      this.off(actionName, prev)\n    }\n\n    if (is.array(cur) || is.object(cur)) {\n      this.on(actionName, cur)\n    }\n  }\n\n  setPerAction (actionName: ActionName, options: OrBoolean<Options>) {\n    const defaults = this._defaults\n\n    // for all the default per-action options\n    for (const optionName_ in options) {\n      const optionName = optionName_ as keyof PerActionDefaults\n      const actionOptions = this.options[actionName]\n      const optionValue: any = options[optionName]\n\n      // remove old event listeners and add new ones\n      if (optionName === 'listeners') {\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue as Listeners)\n      }\n\n      // if the option value is an array\n      if (is.array(optionValue)) {\n        ;(actionOptions[optionName] as any) = arr.from(optionValue)\n      }\n      // if the option value is an object\n      else if (is.plainObject(optionValue)) {\n        // copy the object\n        ;(actionOptions[optionName] as any) = extend(\n          actionOptions[optionName] || ({} as any),\n          clone(optionValue),\n        )\n\n        // set anabled field to true if it exists in the defaults\n        if (\n          is.object(defaults.perAction[optionName]) &&\n          'enabled' in (defaults.perAction[optionName] as any)\n        ) {\n          ;(actionOptions[optionName] as any).enabled = optionValue.enabled !== false\n        }\n      }\n      // if the option value is a boolean and the default is an object\n      else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {\n        ;(actionOptions[optionName] as any).enabled = optionValue\n      }\n      // if it's anything else, do a plain assignment\n      else {\n        ;(actionOptions[optionName] as any) = optionValue\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {Rect} The object's bounding rectangle.\n   */\n  getRect (element: Element) {\n    element = element || (is.element(this.target) ? this.target : null)\n\n    if (is.string(this.target)) {\n      element = element || this._context.querySelector(this.target)\n    }\n\n    return getElementRect(element)\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker(): (element: Element) => any | null\n  rectChecker(checker: (element: Element) => any): this\n  rectChecker (checker?: (element: Element) => any) {\n    if (is.func(checker)) {\n      this._rectChecker = checker\n\n      this.getRect = (element) => {\n        const rect = extend({}, this._rectChecker(element))\n\n        if (!(('width' in rect) as unknown)) {\n          rect.width = rect.right - rect.left\n          rect.height = rect.bottom - rect.top\n        }\n\n        return rect\n      }\n\n      return this\n    }\n\n    if (checker === null) {\n      delete this.getRect\n      delete this._rectChecker\n\n      return this\n    }\n\n    return this.getRect\n  }\n\n  _backCompatOption (optionName: keyof Options, newValue: any) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      ;(this.options[optionName] as any) = newValue\n\n      for (const action in this._actions.map) {\n        ;(this.options[action as keyof ActionMap] as any)[optionName] = newValue\n      }\n\n      return this\n    }\n\n    return this.options[optionName]\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin (newValue: any) {\n    return this._backCompatOption('origin', newValue)\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource(): DeltaSource\n  deltaSource(newValue: DeltaSource): this\n  deltaSource (newValue?: DeltaSource) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue\n\n      return this\n    }\n\n    return this.options.deltaSource\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context () {\n    return this._context\n  }\n\n  inContext (element: Document | Node) {\n    return this._context === element.ownerDocument || nodeContains(this._context, element)\n  }\n\n  testIgnoreAllow (\n    this: Interactable,\n    options: { ignoreFrom?: IgnoreValue, allowFrom?: IgnoreValue },\n    targetNode: Node,\n    eventTarget: Node,\n  ) {\n    return (\n      !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) &&\n      this.testAllow(options.allowFrom, targetNode, eventTarget)\n    )\n  }\n\n  testAllow (this: Interactable, allowFrom: IgnoreValue, targetNode: Node, element: Node) {\n    if (!allowFrom) {\n      return true\n    }\n\n    if (!is.element(element)) {\n      return false\n    }\n\n    if (is.string(allowFrom)) {\n      return matchesUpTo(element, allowFrom, targetNode)\n    } else if (is.element(allowFrom)) {\n      return nodeContains(allowFrom, element)\n    }\n\n    return false\n  }\n\n  testIgnore (this: Interactable, ignoreFrom: IgnoreValue, targetNode: Node, element: Node) {\n    if (!ignoreFrom || !is.element(element)) {\n      return false\n    }\n\n    if (is.string(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, targetNode)\n    } else if (is.element(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element)\n    }\n\n    return false\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire<E extends { type: string }> (iEvent: E) {\n    this.events.fire(iEvent)\n\n    return this\n  }\n\n  _onOff (method: 'on' | 'off', typeArg: EventTypes, listenerArg?: ListenersArg | null, options?: any) {\n    if (is.object(typeArg) && !is.array(typeArg)) {\n      options = listenerArg\n      listenerArg = null\n    }\n\n    const addRemove = method === 'on' ? 'add' : 'remove'\n    const listeners = normalizeListeners(typeArg, listenerArg)\n\n    for (let type in listeners) {\n      if (type === 'wheel') {\n        type = browser.wheelEvent\n      }\n\n      for (const listener of listeners[type]) {\n        // if it is an action event type\n        if (isNonNativeEvent(type, this._actions)) {\n          this.events[method](type, listener)\n        }\n        // delegated event\n        else if (is.string(this.target)) {\n          this._scopeEvents[`${addRemove}Delegate` as 'addDelegate' | 'removeDelegate'](\n            this.target,\n            this._context,\n            type,\n            listener,\n            options,\n          )\n        }\n        // remove listener from this Interactable's element\n        else {\n          this._scopeEvents[addRemove](this.target, type, listener, options)\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} types The types of events to listen\n   * for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * addEventListener\n   * @return {Interactable} This Interactable\n   */\n  on (types: EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff('on', types, listener, options)\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\n   *\n   * @param {string | array | object} types The types of events that were\n   * listened for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {Interactable} This Interactable\n   */\n  off (types: string | string[] | EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff('off', types, listener, options)\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set (options: OptionsArg) {\n    const defaults = this._defaults\n\n    if (!is.object(options)) {\n      options = {}\n    }\n\n    ;(this.options as Required<Options>) = clone(defaults.base) as Required<Options>\n\n    for (const actionName_ in this._actions.methodDict) {\n      const actionName = actionName_ as ActionName\n      const methodName = this._actions.methodDict[actionName]\n\n      this.options[actionName] = {}\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\n      ;(this[methodName] as ActionMethod<unknown>)(options[actionName])\n    }\n\n    for (const setting in options) {\n      if (is.func((this as any)[setting])) {\n        ;(this as any)[setting](options[setting as keyof typeof options])\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   */\n  unset () {\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in this._scopeEvents.delegatedEvents) {\n        const delegated = this._scopeEvents.delegatedEvents[type]\n\n        for (let i = delegated.length - 1; i >= 0; i--) {\n          const { selector, context, listeners } = delegated[i]\n\n          if (selector === this.target && context === this._context) {\n            delegated.splice(i, 1)\n          }\n\n          for (let l = listeners.length - 1; l >= 0; l--) {\n            this._scopeEvents.removeDelegate(\n              this.target,\n              this._context,\n              type,\n              listeners[l][0],\n              listeners[l][1],\n            )\n          }\n        }\n      }\n    } else {\n      this._scopeEvents.remove(this.target as Node, 'all')\n    }\n  }\n}\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type { OptionsArg, Options } from '@interactjs/core/options'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { Target, Context } from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactable:new': {\n      interactable: Interactable\n      target: Target\n      options: OptionsArg\n      win: Window\n    }\n  }\n}\n\ninterface InteractableScopeProp {\n  context: Context\n  interactable: Interactable\n}\n\nexport class InteractableSet {\n  // all set interactables\n  list: Interactable[] = []\n\n  selectorMap: {\n    [selector: string]: InteractableScopeProp[]\n  } = {}\n\n  scope: Scope\n\n  constructor (scope: Scope) {\n    this.scope = scope\n    scope.addListeners({\n      'interactable:unset': ({ interactable }) => {\n        const { target, _context: context } = interactable\n        const targetMappings: InteractableScopeProp[] = is.string(target)\n          ? this.selectorMap[target]\n          : (target as any)[this.scope.id]\n\n        const targetIndex = arr.findIndex(targetMappings, (m) => m.context === context)\n        if (targetMappings[targetIndex]) {\n          // Destroying mappingInfo's context and interactable\n          targetMappings[targetIndex].context = null\n          targetMappings[targetIndex].interactable = null\n        }\n        targetMappings.splice(targetIndex, 1)\n      },\n    })\n  }\n\n  new (target: Target, options?: any): Interactable {\n    options = extend(options || {}, {\n      actions: this.scope.actions,\n    })\n    const interactable = new this.scope.Interactable(target, options, this.scope.document, this.scope.events)\n    const mappingInfo = { context: interactable._context, interactable }\n\n    this.scope.addDocument(interactable._doc)\n    this.list.push(interactable)\n\n    if (is.string(target)) {\n      if (!this.selectorMap[target]) {\n        this.selectorMap[target] = []\n      }\n      this.selectorMap[target].push(mappingInfo)\n    } else {\n      if (!(interactable.target as any)[this.scope.id]) {\n        Object.defineProperty(target, this.scope.id, {\n          value: [],\n          configurable: true,\n        })\n      }\n\n      ;(target as any)[this.scope.id].push(mappingInfo)\n    }\n\n    this.scope.fire('interactable:new', {\n      target,\n      options,\n      interactable,\n      win: this.scope._win,\n    })\n\n    return interactable\n  }\n\n  get (target: Target, options?: Options) {\n    const context = (options && options.context) || this.scope.document\n    const isSelector = is.string(target)\n    const targetMappings: InteractableScopeProp[] = isSelector\n      ? this.selectorMap[target as string]\n      : (target as any)[this.scope.id]\n\n    if (!targetMappings) {\n      return null\n    }\n\n    const found = arr.find(\n      targetMappings,\n      (m) => m.context === context && (isSelector || m.interactable.inContext(target as any)),\n    )\n\n    return found && found.interactable\n  }\n\n  forEachMatch<T> (node: Node, callback: (interactable: Interactable) => T) {\n    for (const interactable of this.list) {\n      let ret: void | T\n\n      if (\n        (is.string(interactable.target)\n          ? // target is a selector and the element matches\n          is.element(node) && domUtils.matchesSelector(node, interactable.target)\n          : // target is the element\n          node === interactable.target) &&\n        // the element is in context\n        interactable.inContext(node)\n      ) {\n        ret = callback(interactable)\n      }\n\n      if (ret !== undefined) {\n        return ret\n      }\n    }\n  }\n}\n", "import type { Scope } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport pExtend from '@interactjs/utils/pointerExtend'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    events: ReturnType<typeof install>\n  }\n}\n\ntype Listener = (event: Event | FakeEvent) => any\n\nfunction install (scope: Scope) {\n  const targets: Array<{\n    eventTarget: EventTarget\n    events: { [type: string]: Listener[] }\n  }> = []\n\n  const delegatedEvents: {\n    [type: string]: Array<{\n      selector: string\n      context: Node\n      listeners: Array<[Listener, { capture: boolean, passive: boolean }]>\n    }>\n  } = {}\n  const documents: Document[] = []\n\n  const eventsMethods = {\n    add,\n    remove,\n\n    addDelegate,\n    removeDelegate,\n\n    delegateListener,\n    delegateUseCapture,\n    delegatedEvents,\n    documents,\n\n    targets,\n\n    supportsOptions: false,\n    supportsPassive: false,\n  }\n\n  // check if browser supports passive events and options arg\n  scope.document?.createElement('div').addEventListener('test', null, {\n    get capture () {\n      return (eventsMethods.supportsOptions = true)\n    },\n    get passive () {\n      return (eventsMethods.supportsPassive = true)\n    },\n  })\n\n  scope.events = eventsMethods\n\n  function add (eventTarget: EventTarget, type: string, listener: Listener, optionalArg?: boolean | any) {\n    const options = getOptions(optionalArg)\n    let target = arr.find(targets, (t) => t.eventTarget === eventTarget)\n\n    if (!target) {\n      target = {\n        eventTarget,\n        events: {},\n      }\n\n      targets.push(target)\n    }\n\n    if (!target.events[type]) {\n      target.events[type] = []\n    }\n\n    if (eventTarget.addEventListener && !arr.contains(target.events[type], listener)) {\n      eventTarget.addEventListener(\n        type,\n        listener as any,\n        eventsMethods.supportsOptions ? options : options.capture,\n      )\n      target.events[type].push(listener)\n    }\n  }\n\n  function remove (\n    eventTarget: EventTarget,\n    type: string,\n    listener?: 'all' | Listener,\n    optionalArg?: boolean | any,\n  ) {\n    const options = getOptions(optionalArg)\n    const targetIndex = arr.findIndex(targets, (t) => t.eventTarget === eventTarget)\n    const target = targets[targetIndex]\n\n    if (!target || !target.events) {\n      return\n    }\n\n    if (type === 'all') {\n      for (type in target.events) {\n        if (target.events.hasOwnProperty(type)) {\n          remove(eventTarget, type, 'all')\n        }\n      }\n      return\n    }\n\n    let typeIsEmpty = false\n    const typeListeners = target.events[type]\n\n    if (typeListeners) {\n      if (listener === 'all') {\n        for (let i = typeListeners.length - 1; i >= 0; i--) {\n          remove(eventTarget, type, typeListeners[i], options)\n        }\n        return\n      } else {\n        for (let i = 0; i < typeListeners.length; i++) {\n          if (typeListeners[i] === listener) {\n            eventTarget.removeEventListener(\n              type,\n              listener as any,\n              eventsMethods.supportsOptions ? options : options.capture,\n            )\n            typeListeners.splice(i, 1)\n\n            if (typeListeners.length === 0) {\n              delete target.events[type]\n              typeIsEmpty = true\n            }\n\n            break\n          }\n        }\n      }\n    }\n\n    if (typeIsEmpty && !Object.keys(target.events).length) {\n      targets.splice(targetIndex, 1)\n    }\n  }\n\n  function addDelegate (selector: string, context: Node, type: string, listener: Listener, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    if (!delegatedEvents[type]) {\n      delegatedEvents[type] = []\n\n      // add delegate listener functions\n      for (const doc of documents) {\n        add(doc, type, delegateListener)\n        add(doc, type, delegateUseCapture, true)\n      }\n    }\n\n    const delegates = delegatedEvents[type]\n    let delegate = arr.find(delegates, (d) => d.selector === selector && d.context === context)\n\n    if (!delegate) {\n      delegate = { selector, context, listeners: [] }\n      delegates.push(delegate)\n    }\n\n    delegate.listeners.push([listener, options])\n  }\n\n  function removeDelegate (\n    selector: string,\n    context: Document | Element,\n    type: string,\n    listener?: Listener,\n    optionalArg?: any,\n  ) {\n    const options = getOptions(optionalArg)\n    const delegates = delegatedEvents[type]\n    let matchFound = false\n    let index: number\n\n    if (!delegates) return\n\n    // count from last index of delegated to 0\n    for (index = delegates.length - 1; index >= 0; index--) {\n      const cur = delegates[index]\n      // look for matching selector and context Node\n      if (cur.selector === selector && cur.context === context) {\n        const { listeners } = cur\n\n        // each item of the listeners array is an array: [function, capture, passive]\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          const [fn, { capture, passive }] = listeners[i]\n\n          // check if the listener functions and capture and passive flags match\n          if (fn === listener && capture === options.capture && passive === options.passive) {\n            // remove the listener from the array of listeners\n            listeners.splice(i, 1)\n\n            // if all listeners for this target have been removed\n            // remove the target from the delegates array\n            if (!listeners.length) {\n              delegates.splice(index, 1)\n\n              // remove delegate function from context\n              remove(context, type, delegateListener)\n              remove(context, type, delegateUseCapture, true)\n            }\n\n            // only remove one listener\n            matchFound = true\n            break\n          }\n        }\n\n        if (matchFound) {\n          break\n        }\n      }\n    }\n  }\n\n  // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n  function delegateListener (event: Event | FakeEvent, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    const fakeEvent = new FakeEvent(event as Event)\n    const delegates = delegatedEvents[event.type]\n    const [eventTarget] = pointerUtils.getEventTargets(event as Event)\n    let element: Node = eventTarget\n\n    // climb up document tree looking for selector matches\n    while (is.element(element)) {\n      for (let i = 0; i < delegates.length; i++) {\n        const cur = delegates[i]\n        const { selector, context } = cur\n\n        if (\n          domUtils.matchesSelector(element, selector) &&\n          domUtils.nodeContains(context, eventTarget) &&\n          domUtils.nodeContains(context, element)\n        ) {\n          const { listeners } = cur\n\n          fakeEvent.currentTarget = element\n\n          for (const [fn, { capture, passive }] of listeners) {\n            if (capture === options.capture && passive === options.passive) {\n              fn(fakeEvent)\n            }\n          }\n        }\n      }\n\n      element = domUtils.parentNode(element)\n    }\n  }\n\n  function delegateUseCapture (this: Element, event: Event | FakeEvent) {\n    return delegateListener.call(this, event, true)\n  }\n\n  // for type inferrence\n  return eventsMethods\n}\n\nclass FakeEvent implements Partial<Event> {\n  currentTarget: Node\n  originalEvent: Event\n  type: string\n\n  constructor (originalEvent: Event) {\n    this.originalEvent = originalEvent\n    // duplicate the event so that currentTarget can be changed\n    pExtend(this, originalEvent)\n  }\n\n  preventOriginalDefault () {\n    this.originalEvent.preventDefault()\n  }\n\n  stopPropagation () {\n    this.originalEvent.stopPropagation()\n  }\n\n  stopImmediatePropagation () {\n    this.originalEvent.stopImmediatePropagation()\n  }\n}\n\nfunction getOptions (param: { [index: string]: any } | boolean): { capture: boolean, passive: boolean } {\n  if (!is.object(param)) {\n    return { capture: !!param, passive: false }\n  }\n\n  const options = extend({}, param) as any\n\n  options.capture = !!param.capture\n  options.passive = !!param.passive\n\n  return options\n}\n\nexport default {\n  id: 'events',\n  install,\n}\n", "import type { PointerEventType, PointerType } from '@interactjs/core/types'\n\nexport class PointerInfo {\n  id: number\n  pointer: PointerType\n  event: PointerEventType\n  downTime: number\n  downTarget: Node\n\n  constructor (id: number, pointer: PointerType, event: PointerEventType, downTime: number, downTarget: Node) {\n    this.id = id\n    this.pointer = pointer\n    this.event = event\n    this.downTime = downTime\n    this.downTarget = downTarget\n  }\n}\n", "import type {\n  Element,\n  EdgeOptions,\n  PointerEventType,\n  PointerType,\n  FullRect,\n  CoordsSet,\n} from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport hypot from '@interactjs/utils/hypot'\nimport { warnOnce, copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type { EventPhase } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport type { Interactable } from './Interactable'\nimport { PointerInfo } from './PointerInfo'\nimport type { ActionDefaults } from './options'\nimport type { Scope } from './scope'\nimport type { ActionName, ActionProps } from './types'\n\nexport enum _ProxyValues {\n  interactable = '',\n  element = '',\n  prepared = '',\n  pointerIsDown = '',\n  pointerWasMoved = '',\n  _proxy = '',\n}\n\nexport enum _ProxyMethods {\n  start = '',\n  move = '',\n  end = '',\n  stop = '',\n  interacting = '',\n}\n\nexport type PointerArgProps<T extends {} = {}> = {\n  pointer: PointerType\n  event: PointerEventType\n  eventTarget: Node\n  pointerIndex: number\n  pointerInfo: PointerInfo\n  interaction: Interaction<never>\n} & T\n\nexport interface DoPhaseArg<T extends ActionName, P extends EventPhase> {\n  event: PointerEventType\n  phase: EventPhase\n  interaction: Interaction<T>\n  iEvent: InteractEvent<T, P>\n  preEnd?: boolean\n  type?: string\n}\n\nexport type DoAnyPhaseArg = DoPhaseArg<ActionName, EventPhase>\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:new': { interaction: Interaction<ActionName> }\n    'interactions:down': PointerArgProps<{\n      type: 'down'\n    }>\n    'interactions:move': PointerArgProps<{\n      type: 'move'\n      dx: number\n      dy: number\n      duplicate: boolean\n    }>\n    'interactions:up': PointerArgProps<{\n      type: 'up'\n      curEventTarget: EventTarget\n    }>\n    'interactions:cancel': SignalArgs['interactions:up'] & {\n      type: 'cancel'\n      curEventTarget: EventTarget\n    }\n    'interactions:update-pointer': PointerArgProps<{\n      down: boolean\n    }>\n    'interactions:remove-pointer': PointerArgProps\n    'interactions:blur': { interaction: Interaction<never>, event: Event, type: 'blur' }\n    'interactions:before-action-start': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-start': DoAnyPhaseArg\n    'interactions:after-action-start': DoAnyPhaseArg\n    'interactions:before-action-move': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-move': DoAnyPhaseArg\n    'interactions:after-action-move': DoAnyPhaseArg\n    'interactions:before-action-end': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-end': DoAnyPhaseArg\n    'interactions:after-action-end': DoAnyPhaseArg\n    'interactions:stop': { interaction: Interaction }\n  }\n}\n\nexport type InteractionProxy<T extends ActionName | null = never> = Pick<\nInteraction<T>,\nkeyof typeof _ProxyValues | keyof typeof _ProxyMethods\n>\n\nlet idCounter = 0\n\nexport class Interaction<T extends ActionName | null = ActionName> {\n  // current interactable being interacted with\n  interactable: Interactable | null = null\n\n  // the target element of the interactable\n  element: Element | null = null\n  rect: FullRect | null = null\n  _rects?: {\n    start: FullRect\n    corrected: FullRect\n    previous: FullRect\n    delta: FullRect\n  }\n  edges: EdgeOptions | null = null\n\n  _scopeFire: Scope['fire']\n\n  // action that's ready to be fired on next move event\n  prepared: ActionProps<T> = {\n    name: null,\n    axis: null,\n    edges: null,\n  }\n\n  pointerType: string\n\n  // keep track of added pointers\n  pointers: PointerInfo[] = []\n\n  // pointerdown/mousedown/touchstart event\n  downEvent: PointerEventType | null = null\n\n  downPointer: PointerType = {} as PointerType\n\n  _latestPointer: {\n    pointer: PointerType\n    event: PointerEventType\n    eventTarget: Node\n  } = {\n      pointer: null,\n      event: null,\n      eventTarget: null,\n    }\n\n  // previous action event\n  prevEvent: InteractEvent<T, EventPhase> = null\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  _interacting = false\n  _ending = false\n  _stopped = true\n  _proxy: InteractionProxy<T> | null = null\n\n  simulation = null\n\n  /** @internal */ get pointerMoveTolerance () {\n    return 1\n  }\n\n  /**\n   * @alias Interaction.prototype.move\n   */\n  doMove = warnOnce(function (this: Interaction, signalArg: any) {\n    this.move(signalArg)\n  }, 'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords: CoordsSet = {\n    // Starting InteractEvent pointer coordinates\n    start: pointerUtils.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: pointerUtils.newCoords(),\n    // current native pointer move event coordinates\n    cur: pointerUtils.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: pointerUtils.newCoords(),\n    // pointer velocity\n    velocity: pointerUtils.newCoords(),\n  }\n\n  readonly _id: number = idCounter++\n\n  /** */\n  constructor ({ pointerType, scopeFire }: { pointerType?: string, scopeFire: Scope['fire'] }) {\n    this._scopeFire = scopeFire\n    this.pointerType = pointerType\n\n    const that = this\n\n    this._proxy = {} as InteractionProxy<T>\n\n    for (const key in _ProxyValues) {\n      Object.defineProperty(this._proxy, key, {\n        get () {\n          return that[key]\n        },\n      })\n    }\n\n    for (const key in _ProxyMethods) {\n      Object.defineProperty(this._proxy, key, {\n        value: (...args: any[]) => that[key](...args),\n      })\n    }\n\n    this._scopeFire('interactions:new', { interaction: this })\n  }\n\n  pointerDown (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      pointerInfo,\n      type: 'down',\n      interaction: this as unknown as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget)\n   *     }\n   * })\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param {object} action   The action to be performed - drag, resize, etc.\n   * @param {Interactable} target  The Interactable to target\n   * @param {Element} element The DOM Element to target\n   * @return {Boolean} Whether the interaction was successfully started\n   */\n  start<A extends ActionName> (action: ActionProps<A>, interactable: Interactable, element: Element): boolean {\n    if (\n      this.interacting() ||\n      !this.pointerIsDown ||\n      this.pointers.length < (action.name === 'gesture' ? 2 : 1) ||\n      !interactable.options[action.name as keyof ActionDefaults].enabled\n    ) {\n      return false\n    }\n\n    copyAction(this.prepared, action)\n\n    this.interactable = interactable\n    this.element = element\n    this.rect = interactable.getRect(element)\n    this.edges = this.prepared.edges\n      ? extend({}, this.prepared.edges)\n      : { left: true, right: true, top: true, bottom: true }\n    this._stopped = false\n    this._interacting =\n      this._doPhase({\n        interaction: this,\n        event: this.downEvent,\n        phase: 'start',\n      }) && !this._stopped\n\n    return this._interacting\n  }\n\n  pointerMove (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    if (!this.simulation && !(this.modification && this.modification.endResult)) {\n      this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const duplicateMove =\n      this.coords.cur.page.x === this.coords.prev.page.x &&\n      this.coords.cur.page.y === this.coords.prev.page.y &&\n      this.coords.cur.client.x === this.coords.prev.client.x &&\n      this.coords.cur.client.y === this.coords.prev.client.y\n\n    let dx: number\n    let dy: number\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance\n    }\n\n    const pointerIndex = this.getPointerIndex(pointer)\n    const signalArg = {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      type: 'move' as const,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: this as unknown as Interaction<never>,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      pointerUtils.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._scopeFire('interactions:move', signalArg)\n\n    if (!duplicateMove && !this.simulation) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        signalArg.type = null\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }})\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move()\n   *     }\n   *   })\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move (signalArg?: any) {\n    if (!signalArg || !signalArg.event) {\n      pointerUtils.setZeroCoords(this.coords.delta)\n    }\n\n    signalArg = extend(\n      {\n        pointer: this._latestPointer.pointer,\n        event: this._latestPointer.event,\n        eventTarget: this._latestPointer.eventTarget,\n        interaction: this,\n      },\n      signalArg || {},\n    )\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  // End interact move events and stop auto-scroll unless simulation is running\n  pointerUp (pointer: PointerType, event: PointerEventType, eventTarget: Node, curEventTarget: EventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\n\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      eventTarget,\n      type: type as any,\n      curEventTarget,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.removePointer(pointer, event)\n  }\n\n  documentBlur (event: Event) {\n    this.end(event as any)\n    this._scopeFire('interactions:blur', {\n      event,\n      type: 'blur',\n      interaction: this as unknown as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end()\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation()\n   *     }\n   *   })\n   * ```\n   *\n   * @param {PointerEvent} [event]\n   */\n  end (event?: PointerEventType) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult: boolean\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction () {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting () {\n    return this._interacting\n  }\n\n  /** */\n  stop () {\n    this._scopeFire('interactions:stop', { interaction: this })\n\n    this.interactable = this.element = null\n\n    this._interacting = false\n    this._stopped = true\n    this.prepared.name = this.prevEvent = null\n  }\n\n  getPointerIndex (pointer: any) {\n    const pointerId = pointerUtils.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return this.pointerType === 'mouse' || this.pointerType === 'pen'\n      ? this.pointers.length - 1\n      : arr.findIndex(this.pointers, (curPointer) => curPointer.id === pointerId)\n  }\n\n  getPointerInfo (pointer: any) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  updatePointer (pointer: PointerType, event: PointerEventType, eventTarget: Node, down?: boolean) {\n    const id = pointerUtils.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false ? false : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(id, pointer, event, null, null)\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    } else {\n      pointerInfo.pointer = pointer\n    }\n\n    pointerUtils.setCoords(\n      this.coords.cur,\n      this.pointers.map((p) => p.pointer),\n      this._now(),\n    )\n    pointerUtils.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n\n    if (down) {\n      this.pointerIsDown = true\n\n      pointerInfo.downTime = this.coords.cur.timeStamp\n      pointerInfo.downTarget = eventTarget\n      pointerUtils.pointerExtend(this.downPointer, pointer)\n\n      if (!this.interacting()) {\n        pointerUtils.copyCoords(this.coords.start, this.coords.cur)\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n\n        this.downEvent = event\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._scopeFire('interactions:update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    return pointerIndex\n  }\n\n  removePointer (pointer: PointerType, event: PointerEventType) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) return\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:remove-pointer', {\n      pointer,\n      event,\n      eventTarget: null,\n      pointerIndex,\n      pointerInfo,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n    this.pointerIsDown = false\n  }\n\n  _updateLatestPointer (pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  destroy () {\n    this._latestPointer.pointer = null\n    this._latestPointer.event = null\n    this._latestPointer.eventTarget = null\n  }\n\n  _createPreparedEvent<P extends EventPhase> (\n    event: PointerEventType,\n    phase: P,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    return new InteractEvent<T, P>(this, event, this.prepared.name, phase, this.element, preEnd, type)\n  }\n\n  _fireEvent<P extends EventPhase> (iEvent: InteractEvent<T, P>) {\n    this.interactable?.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  _doPhase<P extends EventPhase> (\n    signalArg: Omit<DoPhaseArg<T, P>, 'iEvent'> & { iEvent?: InteractEvent<T, P> },\n  ) {\n    const { event, phase, preEnd, type } = signalArg\n    const { rect } = this\n\n    if (rect && phase === 'move') {\n      // update the rect changes due to pointer move\n      rectUtils.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\n\n      rect.width = rect.right - rect.left\n      rect.height = rect.bottom - rect.top\n    }\n\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\n\n    if (beforeResult === false) {\n      return false\n    }\n\n    const iEvent = (signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type))\n\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\n\n    if (phase === 'start') {\n      this.prevEvent = iEvent\n    }\n\n    this._fireEvent(iEvent)\n\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\n\n    return true\n  }\n\n  _now () {\n    return Date.now()\n  }\n}\n\nexport default Interaction\nexport { PointerInfo }\n", "import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerEventType } from '@interactjs/core/types'\nimport { matchesSelector, nodeContains } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    preventDefault: typeof preventDefault\n    checkAndPreventDefault: (event: Event) => void\n  }\n}\n\ntype PreventDefaultValue = 'always' | 'never' | 'auto'\nfunction preventDefault(this: Interactable): PreventDefaultValue\nfunction preventDefault(this: Interactable, newValue: PreventDefaultValue): typeof this\nfunction preventDefault (this: Interactable, newValue?: PreventDefaultValue) {\n  if (/^(always|never|auto)$/.test(newValue)) {\n    this.options.preventDefault = newValue\n    return this\n  }\n\n  if (is.bool(newValue)) {\n    this.options.preventDefault = newValue ? 'always' : 'never'\n    return this\n  }\n\n  return this.options.preventDefault\n}\n\nfunction checkAndPreventDefault (interactable: Interactable, scope: Scope, event: Event) {\n  const setting = interactable.options.preventDefault\n\n  if (setting === 'never') return\n\n  if (setting === 'always') {\n    event.preventDefault()\n    return\n  }\n\n  // setting === 'auto'\n\n  // if the browser supports passive event listeners and isn't running on iOS,\n  // don't preventDefault of touch{start,move} events. CSS touch-action and\n  // user-select should be used instead of calling event.preventDefault().\n  if (scope.events.supportsPassive && /^touch(start|move)$/.test(event.type)) {\n    const doc = getWindow(event.target).document\n    const docOptions = scope.getDocOptions(doc)\n\n    if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {\n      return\n    }\n  }\n\n  // don't preventDefault of pointerdown events\n  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {\n    return\n  }\n\n  // don't preventDefault on editable elements\n  if (\n    is.element(event.target) &&\n    matchesSelector(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')\n  ) {\n    return\n  }\n\n  event.preventDefault()\n}\n\nfunction onInteractionEvent ({ interaction, event }: { interaction: Interaction, event: PointerEventType }) {\n  if (interaction.interactable) {\n    interaction.interactable.checkAndPreventDefault(event as Event)\n  }\n}\n\nexport function install (scope: Scope) {\n  /** @lends Interactable */\n  const { Interactable } = scope\n\n  /**\n   * Returns or sets whether to prevent the browser's default behaviour in\n   * response to pointer events. Can be set to:\n   *  - `'always'` to always prevent\n   *  - `'never'` to never prevent\n   *  - `'auto'` to let interact.js try to determine what would be best\n   *\n   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`\n   * @return {string | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.preventDefault = preventDefault\n\n  Interactable.prototype.checkAndPreventDefault = function (event) {\n    return checkAndPreventDefault(this, scope, event)\n  }\n\n  // prevent native HTML5 drag on interact.js target elements\n  scope.interactions.docEvents.push({\n    type: 'dragstart',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        if (\n          interaction.element &&\n          (interaction.element === event.target || nodeContains(interaction.element, event.target))\n        ) {\n          interaction.interactable.checkAndPreventDefault(event)\n          return\n        }\n      }\n    },\n  })\n}\n\nexport default {\n  id: 'core/interactablePreventDefault',\n  install,\n  listeners: ['down', 'move', 'up', 'cancel'].reduce((acc, eventType) => {\n    acc[`interactions:${eventType}`] = onInteractionEvent\n    return acc\n  }, {} as any),\n}\n", "import type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/core/types'\nimport * as dom from '@interactjs/utils/domUtils'\n\nexport interface SearchDetails {\n  pointer: PointerType\n  pointerId: number\n  pointerType: string\n  eventType: string\n  eventTarget: EventTarget\n  curEventTarget: EventTarget\n  scope: Scope\n}\n\nconst finder = {\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'] as const,\n\n  search (details: SearchDetails) {\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details)\n\n      if (interaction) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume ({ pointerType, eventType, eventTarget, scope }: SearchDetails) {\n    if (!/down|start/i.test(eventType)) {\n      return null\n    }\n\n    for (const interaction of scope.interactions.list) {\n      let element = eventTarget as Node\n\n      if (\n        interaction.simulation &&\n        interaction.simulation.allowResume &&\n        interaction.pointerType === pointerType\n      ) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction\n          }\n          element = dom.parentNode(element)\n        }\n      }\n    }\n\n    return null\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen ({ pointerId, pointerType, eventType, scope }: SearchDetails) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null\n    }\n\n    let firstNonActive\n\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !hasPointerId(interaction, pointerId)) {\n          continue\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get interaction that has this pointer\n  hasPointer ({ pointerId, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      if (hasPointerId(interaction, pointerId)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle ({ pointerType, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      // if there's already a pointer held down\n      if (interaction.pointers.length === 1) {\n        const target = interaction.interactable\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !(target.options.gesture && target.options.gesture.enabled)) {\n          continue\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointers.length >= 2) {\n        continue\n      }\n\n      if (!interaction.interacting() && pointerType === interaction.pointerType) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n}\n\nfunction hasPointerId (interaction: Interaction, pointerId: number) {\n  return interaction.pointers.some(({ id }) => id === pointerId)\n}\n\nexport default finder\n", "import type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { ActionName, Listener } from '@interactjs/core/types'\nimport browser from '@interactjs/utils/browser'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { nodeContains } from '@interactjs/utils/domUtils'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport InteractionBase from './Interaction'\nimport interactablePreventDefault from './interactablePreventDefault'\nimport type { SearchDetails } from './interactionFinder'\nimport finder from './interactionFinder'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    Interaction: typeof InteractionBase\n    interactions: {\n      new: <T extends ActionName>(options: any) => InteractionBase<T>\n      list: Array<InteractionBase<ActionName>>\n      listeners: { [type: string]: Listener }\n      docEvents: Array<{ type: string, listener: Listener }>\n      pointerMoveTolerance: number\n    }\n    prevTouchTime: number\n  }\n\n  interface SignalArgs {\n    'interactions:find': {\n      interaction: InteractionBase\n      searchDetails: SearchDetails\n    }\n  }\n}\n\nconst methodNames = [\n  'pointerDown',\n  'pointerMove',\n  'pointerUp',\n  'updatePointer',\n  'removePointer',\n  'windowBlur',\n]\n\nfunction install (scope: Scope) {\n  const listeners = {} as any\n\n  for (const method of methodNames) {\n    listeners[method] = doOnInteractions(method, scope)\n  }\n\n  const pEventTypes = browser.pEventTypes\n  let docEvents: typeof scope.interactions.docEvents\n\n  if (domObjects.PointerEvent) {\n    docEvents = [\n      { type: pEventTypes.down, listener: releasePointersOnRemovedEls },\n      { type: pEventTypes.down, listener: listeners.pointerDown },\n      { type: pEventTypes.move, listener: listeners.pointerMove },\n      { type: pEventTypes.up, listener: listeners.pointerUp },\n      { type: pEventTypes.cancel, listener: listeners.pointerUp },\n    ]\n  } else {\n    docEvents = [\n      { type: 'mousedown', listener: listeners.pointerDown },\n      { type: 'mousemove', listener: listeners.pointerMove },\n      { type: 'mouseup', listener: listeners.pointerUp },\n\n      { type: 'touchstart', listener: releasePointersOnRemovedEls },\n      { type: 'touchstart', listener: listeners.pointerDown },\n      { type: 'touchmove', listener: listeners.pointerMove },\n      { type: 'touchend', listener: listeners.pointerUp },\n      { type: 'touchcancel', listener: listeners.pointerUp },\n    ]\n  }\n\n  docEvents.push({\n    type: 'blur',\n    listener (event) {\n      for (const interaction of scope.interactions.list) {\n        interaction.documentBlur(event)\n      }\n    },\n  })\n\n  // for ignoring browser's simulated mouse events\n  scope.prevTouchTime = 0\n\n  scope.Interaction = class <T extends ActionName> extends InteractionBase<T> {\n    get pointerMoveTolerance () {\n      return scope.interactions.pointerMoveTolerance\n    }\n\n    set pointerMoveTolerance (value) {\n      scope.interactions.pointerMoveTolerance = value\n    }\n\n    _now () {\n      return scope.now()\n    }\n  }\n\n  scope.interactions = {\n    // all active and idle interactions\n    list: [],\n    new<T extends ActionName> (options: { pointerType?: string, scopeFire?: Scope['fire'] }) {\n      options.scopeFire = (name, arg) => scope.fire(name, arg)\n\n      const interaction = new scope.Interaction<T>(options as Required<typeof options>)\n\n      scope.interactions.list.push(interaction)\n      return interaction\n    },\n    listeners,\n    docEvents,\n    pointerMoveTolerance: 1,\n  }\n\n  function releasePointersOnRemovedEls () {\n    // for all inactive touch interactions with pointers down\n    for (const interaction of scope.interactions.list) {\n      if (!interaction.pointerIsDown || interaction.pointerType !== 'touch' || interaction._interacting) {\n        continue\n      }\n\n      // if a pointer is down on an element that is no longer in the DOM tree\n      for (const pointer of interaction.pointers) {\n        if (!scope.documents.some(({ doc }) => nodeContains(doc, pointer.downTarget))) {\n          // remove the pointer from the interaction\n          interaction.removePointer(pointer.pointer, pointer.event)\n        }\n      }\n    }\n  }\n\n  scope.usePlugin(interactablePreventDefault)\n}\n\nfunction doOnInteractions (method: string, scope: Scope) {\n  return function (event: Event) {\n    const interactions = scope.interactions.list\n\n    const pointerType = pointerUtils.getPointerType(event)\n    const [eventTarget, curEventTarget] = pointerUtils.getEventTargets(event)\n    const matches: any[] = [] // [ [pointer, interaction], ...]\n\n    if (/^touch/.test(event.type)) {\n      scope.prevTouchTime = scope.now()\n\n      // @ts-expect-error\n      for (const changedTouch of event.changedTouches) {\n        const pointer = changedTouch\n        const pointerId = pointerUtils.getPointerId(pointer)\n        const searchDetails: SearchDetails = {\n          pointer,\n          pointerId,\n          pointerType,\n          eventType: event.type,\n          eventTarget,\n          curEventTarget,\n          scope,\n        }\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    } else {\n      let invalidPointer = false\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < interactions.length && !invalidPointer; i++) {\n          invalidPointer = interactions[i].pointerType !== 'mouse' && interactions[i].pointerIsDown\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer =\n          invalidPointer ||\n          scope.now() - scope.prevTouchTime < 500 ||\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n          event.timeStamp === 0\n      }\n\n      if (!invalidPointer) {\n        const searchDetails = {\n          pointer: event as PointerEvent,\n          pointerId: pointerUtils.getPointerId(event as PointerEvent),\n          pointerType,\n          eventType: event.type,\n          curEventTarget,\n          eventTarget,\n          scope,\n        }\n\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    }\n\n    // eslint-disable-next-line no-shadow\n    for (const [pointer, eventTarget, curEventTarget, interaction] of matches) {\n      interaction[method](pointer, event, eventTarget, curEventTarget)\n    }\n  }\n}\n\nfunction getInteraction (searchDetails: SearchDetails) {\n  const { pointerType, scope } = searchDetails\n\n  const foundInteraction = finder.search(searchDetails)\n  const signalArg = { interaction: foundInteraction, searchDetails }\n\n  scope.fire('interactions:find', signalArg)\n\n  return signalArg.interaction || scope.interactions.new({ pointerType })\n}\n\nfunction onDocSignal<T extends 'scope:add-document' | 'scope:remove-document'> (\n  { doc, scope, options }: SignalArgs[T],\n  eventMethodName: 'add' | 'remove',\n) {\n  const {\n    interactions: { docEvents },\n    events,\n  } = scope\n  const eventMethod = events[eventMethodName]\n\n  if (scope.browser.isIOS && !options.events) {\n    options.events = { passive: false }\n  }\n\n  // delegate event listener\n  for (const eventType in events.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener)\n    eventMethod(doc, eventType, events.delegateUseCapture, true)\n  }\n\n  const eventOptions = options && options.events\n\n  for (const { type, listener } of docEvents) {\n    eventMethod(doc, type, listener, eventOptions)\n  }\n}\n\nconst interactions: Plugin = {\n  id: 'core/interactions',\n  install,\n  listeners: {\n    'scope:add-document': (arg) => onDocSignal(arg, 'add'),\n    'scope:remove-document': (arg) => onDocSignal(arg, 'remove'),\n    'interactable:unset': ({ interactable }, scope) => {\n      // Stop and destroy related interactions when an Interactable is unset\n      for (let i = scope.interactions.list.length - 1; i >= 0; i--) {\n        const interaction = scope.interactions.list[i]\n\n        if (interaction.interactable !== interactable) {\n          continue\n        }\n\n        interaction.stop()\n        scope.fire('interactions:destroy', { interaction })\n        interaction.destroy()\n\n        if (scope.interactions.list.length > 2) {\n          scope.interactions.list.splice(i, 1)\n        }\n      }\n    },\n  },\n  onDocSignal,\n  doOnInteractions,\n  methodNames,\n}\n\nexport default interactions\n", "import type Interaction from '@interactjs/core/Interaction'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport domObjects from '@interactjs/utils/domObjects'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport * as win from '@interactjs/utils/window'\n\nimport { Eventable } from './Eventable'\nimport { InteractEvent } from './InteractEvent'\nimport { createInteractStatic } from './InteractStatic'\nimport { Interactable as InteractableBase } from './Interactable'\nimport { InteractableSet } from './InteractableSet'\nimport events from './events'\nimport interactions from './interactions'\nimport type { OptionsArg } from './options'\nimport { defaults } from './options'\nimport type { Actions } from './types'\n\nexport interface SignalArgs {\n  'scope:add-document': DocSignalArg\n  'scope:remove-document': DocSignalArg\n  'interactable:unset': { interactable: InteractableBase }\n  'interactable:set': { interactable: InteractableBase, options: OptionsArg }\n  'interactions:destroy': { interaction: Interaction }\n}\n\nexport type ListenerName = keyof SignalArgs\n\nexport type ListenerMap = {\n  [P in ListenerName]?: (arg: SignalArgs[P], scope: Scope, signalName: P) => void | boolean\n}\n\ninterface DocSignalArg {\n  doc: Document\n  window: Window\n  scope: Scope\n  options: Record<string, any>\n}\n\nexport interface Plugin {\n  [key: string]: any\n  id?: string\n  listeners?: ListenerMap\n  before?: string[]\n  install?(scope: Scope, options?: any): void\n}\n\nexport class Scope {\n  id = `__interact_scope_${Math.floor(Math.random() * 100)}`\n  isInitialized = false\n  listenerMaps: Array<{\n    map: ListenerMap\n    id: string\n  }> = []\n\n  browser = browser\n  defaults = clone(defaults) as typeof defaults\n  Eventable = Eventable\n  actions: Actions = {\n    map: {},\n    phases: {\n      start: true,\n      move: true,\n      end: true,\n    },\n    methodDict: {} as any,\n    phaselessTypes: {},\n  }\n\n  interactStatic = createInteractStatic(this)\n  InteractEvent = InteractEvent\n  Interactable: typeof InteractableBase\n  interactables = new InteractableSet(this)\n\n  // main window\n  _win!: Window\n\n  // main document\n  document!: Document\n\n  // main window\n  window!: Window\n\n  // all documents being listened to\n  documents: Array<{ doc: Document, options: any }> = []\n\n  _plugins: {\n    list: Plugin[]\n    map: { [id: string]: Plugin }\n  } = {\n      list: [],\n      map: {},\n    }\n\n  constructor () {\n    const scope = this\n\n    this.Interactable = class extends InteractableBase {\n      get _defaults () {\n        return scope.defaults\n      }\n\n      set<T extends InteractableBase> (this: T, options: OptionsArg) {\n        super.set(options)\n\n        scope.fire('interactable:set', {\n          options,\n          interactable: this,\n        })\n\n        return this\n      }\n\n      unset (this: InteractableBase) {\n        super.unset()\n\n        const index = scope.interactables.list.indexOf(this)\n        if (index < 0) return\n\n        scope.interactables.list.splice(index, 1)\n        scope.fire('interactable:unset', { interactable: this })\n      }\n    }\n  }\n\n  addListeners (map: ListenerMap, id?: string) {\n    this.listenerMaps.push({ id, map })\n  }\n\n  fire<T extends ListenerName> (name: T, arg: SignalArgs[T]): void | false {\n    for (const {\n      map: { [name]: listener },\n    } of this.listenerMaps) {\n      if (!!listener && listener(arg as any, this, name as never) === false) {\n        return false\n      }\n    }\n  }\n\n  onWindowUnload = (event: BeforeUnloadEvent) => this.removeDocument(event.target as Document)\n\n  init (window: Window | typeof globalThis) {\n    return this.isInitialized ? this : initScope(this, window)\n  }\n\n  pluginIsInstalled (plugin: Plugin) {\n    return this._plugins.map[plugin.id] || this._plugins.list.indexOf(plugin) !== -1\n  }\n\n  usePlugin (plugin: Plugin, options?: { [key: string]: any }) {\n    if (!this.isInitialized) {\n      return this\n    }\n\n    if (this.pluginIsInstalled(plugin)) {\n      return this\n    }\n\n    if (plugin.id) {\n      this._plugins.map[plugin.id] = plugin\n    }\n    this._plugins.list.push(plugin)\n\n    if (plugin.install) {\n      plugin.install(this, options)\n    }\n\n    if (plugin.listeners && plugin.before) {\n      let index = 0\n      const len = this.listenerMaps.length\n      const before = plugin.before.reduce((acc, id) => {\n        acc[id] = true\n        acc[pluginIdRoot(id)] = true\n        return acc\n      }, {})\n\n      for (; index < len; index++) {\n        const otherId = this.listenerMaps[index].id\n\n        if (before[otherId] || before[pluginIdRoot(otherId)]) {\n          break\n        }\n      }\n\n      this.listenerMaps.splice(index, 0, { id: plugin.id, map: plugin.listeners })\n    } else if (plugin.listeners) {\n      this.listenerMaps.push({ id: plugin.id, map: plugin.listeners })\n    }\n\n    return this\n  }\n\n  addDocument (doc: Document, options?: any): void | false {\n    // do nothing if document is already known\n    if (this.getDocIndex(doc) !== -1) {\n      return false\n    }\n\n    const window = win.getWindow(doc)\n\n    options = options ? extend({}, options) : {}\n\n    this.documents.push({ doc, options })\n    this.events.documents.push(doc)\n\n    // don't add an unload event for the main document\n    // so that the page may be cached in browser history\n    if (doc !== this.document) {\n      this.events.add(window, 'unload', this.onWindowUnload)\n    }\n\n    this.fire('scope:add-document', { doc, window, scope: this, options })\n  }\n\n  removeDocument (doc: Document) {\n    const index = this.getDocIndex(doc)\n\n    const window = win.getWindow(doc)\n    const options = this.documents[index].options\n\n    this.events.remove(window, 'unload', this.onWindowUnload)\n\n    this.documents.splice(index, 1)\n    this.events.documents.splice(index, 1)\n\n    this.fire('scope:remove-document', { doc, window, scope: this, options })\n  }\n\n  getDocIndex (doc: Document) {\n    for (let i = 0; i < this.documents.length; i++) {\n      if (this.documents[i].doc === doc) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getDocOptions (doc: Document) {\n    const docIndex = this.getDocIndex(doc)\n\n    return docIndex === -1 ? null : this.documents[docIndex].options\n  }\n\n  now () {\n    return (((this.window as any).Date as typeof Date) || Date).now()\n  }\n}\n\nexport function initScope (scope: Scope, window: Window | typeof globalThis) {\n  scope.isInitialized = true\n\n  if (is.window(window)) {\n    win.init(window)\n  }\n\n  domObjects.init(window)\n  browser.init(window)\n  raf.init(window)\n\n  // @ts-expect-error\n  scope.window = window\n  scope.document = window.document\n\n  scope.usePlugin(interactions)\n  scope.usePlugin(events)\n\n  return scope\n}\n\nfunction pluginIdRoot (id: string) {\n  return id && id.replace(/\\/.*$/, '')\n}\n", "import { Scope } from '@interactjs/core/scope'\n\nconst scope = new Scope()\n\nconst interact = scope.interactStatic\n\nexport default interact\n\nconst _global = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : this\nscope.init(_global)\n"],
  "mappings": "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",
  "names": ["domObjects", "init", "document", "DocumentFragment", "SVGElement", "SVGSVGElement", "SVGElementInstance", "Element", "HTMLElement", "Event", "Touch", "PointerEvent", "blank", "window", "win", "MSPointerEvent", "thing", "Window", "realWindow", "undefined", "win", "init", "window", "realWindow", "el", "document", "createTextNode", "ownerDocument", "wrap", "win", "getWindow", "node", "isWindow", "rootNode", "defaultView", "window", "thing", "isWindow", "docFrag", "object", "nodeType", "func", "number", "bool", "string", "element", "_window", "getWindow", "test", "Element", "nodeName", "plainObject", "constructor", "toString", "array", "length", "splice", "browser", "init", "supportsTouch", "supportsPointerEvent", "isIOS7", "isIOS", "isIe9", "isOperaMobile", "prefixedMatchesSelector", "pEventTypes", "wheelEvent", "window", "Element", "domObjects", "navigator", "is", "func", "DocumentTouch", "document", "pointerEnabled", "PointerEvent", "test", "platform", "appVersion", "userAgent", "appName", "prototype", "MSPointerEvent", "up", "down", "over", "out", "move", "cancel", "contains", "array", "target", "indexOf", "merge", "target", "source", "item", "push", "from", "findIndex", "array", "func", "i", "length", "find", "source", "dest", "prop", "value", "is", "plainObject", "clone", "array", "from", "dest", "source", "prop", "ret", "lastTime", "request", "cancel", "init", "global", "requestAnimationFrame", "cancelAnimationFrame", "vendors", "vendor", "bind", "callback", "currTime", "Date", "now", "timeToCall", "Math", "max", "token", "setTimeout", "clearTimeout", "type", "listeners", "result", "is", "string", "search", "split", "array", "reduce", "acc", "t", "extend", "normalize", "object", "func", "push", "l", "prefix", "combinedTypes", "map", "p", "trim", "fireUntilImmediateStopped", "event", "listeners", "listener", "immediatePropagationStopped", "Eventable", "constructor", "options", "types", "propagationStopped", "global", "extend", "fire", "type", "on", "normalize", "merge", "off", "eventList", "length", "subListener", "index", "indexOf", "splice", "getRect", "_element", "nodeContains", "parent", "child", "contains", "parentNode", "closest", "element", "selector", "is", "matchesSelector", "node", "docFrag", "host", "window", "realWindow", "replace", "browser", "prefixedMatchesSelector", "matchesUpTo", "element", "selector", "limit", "is", "matchesSelector", "parentNode", "getActualElement", "correspondingUseElement", "getScrollXY", "relevantWindow", "window", "x", "scrollX", "document", "documentElement", "scrollLeft", "y", "scrollY", "scrollTop", "getElementClientRect", "clientRect", "domObjects", "SVGElement", "getBoundingClientRect", "getClientRects", "left", "right", "top", "bottom", "width", "height", "getElementRect", "browser", "isIOS7", "scroll", "getWindow", "trySelector", "value", "is", "string", "domObjects", "document", "querySelector", "getStringOptionResult", "value", "target", "element", "parentNode", "getRect", "closest", "resolveRectLike", "functionArgs", "returnValue", "is", "string", "func", "getElementRect", "rectToXY", "rect", "x", "left", "y", "top", "xywhToTlbr", "extend", "right", "width", "bottom", "height", "tlbrToXywh", "addEdges", "edges", "delta", "target", "element", "actionName", "actionOptions", "options", "actionOrigin", "origin", "originRect", "resolveRectLike", "rectToXY", "x", "y", "x", "y", "Math", "sqrt", "BaseEvent", "constructor", "interaction", "immediatePropagationStopped", "propagationStopped", "_interaction", "preventDefault", "stopPropagation", "stopImmediatePropagation", "Object", "defineProperty", "prototype", "get", "_proxy", "set", "defaults", "base", "preventDefault", "deltaSource", "perAction", "enabled", "origin", "x", "y", "actions", "InteractEvent", "BaseEvent", "constructor", "interaction", "event", "actionName", "phase", "element", "preEnd", "type", "relatedTarget", "screenX", "screenY", "button", "buttons", "ctrlKey", "shiftKey", "altKey", "metaKey", "page", "client", "delta", "rect", "x0", "y0", "t0", "dt", "duration", "clientX0", "clientY0", "velocity", "speed", "swipe", "axes", "target", "interactable", "deltaSource", "options", "defaults", "origin", "getOriginXY", "starting", "ending", "prevEvent", "coords", "start", "timeStamp", "cur", "extend", "x", "y", "currentTarget", "pointers", "length", "downTime", "hypot", "getSwipe", "_interaction", "angle", "Math", "atan2", "velocityY", "velocityX", "PI", "overlap", "left", "up", "right", "down", "preventDefault", "stopImmediatePropagation", "immediatePropagationStopped", "propagationStopped", "stopPropagation", "Object", "defineProperties", "prototype", "pageX", "get", "set", "value", "pageY", "clientX", "clientY", "dx", "dy", "warnOnce", "method", "message", "warned", "window", "console", "warn", "apply", "arguments", "copyAction", "dest", "src", "name", "axis", "edges", "VENDOR_PREFIXES", "dest", "source", "__set", "prop", "some", "prefix", "indexOf", "Object", "defineProperty", "get", "set", "value", "configurable", "copyCoords", "dest", "src", "page", "x", "y", "client", "timeStamp", "setCoordDeltas", "targetObj", "prev", "cur", "setCoordVelocity", "delta", "dt", "Math", "max", "setZeroCoords", "isNativePointer", "pointer", "dom", "Event", "Touch", "getXY", "type", "xy", "getPageXY", "browser", "isOperaMobile", "window", "scrollX", "scrollY", "getClientXY", "getPointerId", "is", "number", "pointerId", "identifier", "setCoords", "pointers", "length", "pointerAverage", "getTouchPair", "event", "touches", "array", "changedTouches", "average", "pageX", "pageY", "clientX", "clientY", "screenX", "screenY", "prop", "touchBBox", "minX", "min", "minY", "maxX", "maxY", "left", "top", "right", "bottom", "width", "height", "touchDistance", "deltaSource", "sourceX", "sourceY", "dx", "dy", "hypot", "touchAngle", "angle", "atan2", "PI", "getPointerType", "string", "pointerType", "undefined", "test", "getEventTargets", "path", "func", "composedPath", "getActualElement", "target", "currentTarget", "newCoords", "type", "actions", "phaselessTypes", "name", "map", "indexOf", "substr", "length", "phases", "createInteractStatic", "scope", "interact", "target", "options", "interactable", "interactables", "get", "new", "events", "global", "globalEvents", "getPointerAverage", "pointerAverage", "getTouchBBox", "touchBBox", "getTouchDistance", "touchDistance", "getTouchAngle", "touchAngle", "getElementRect", "getElementClientRect", "matchesSelector", "closest", "version", "use", "plugin", "usePlugin", "isSet", "context", "on", "warnOnce", "type", "listener", "is", "string", "search", "trim", "split", "array", "eventType", "object", "prop", "isNonNativeEvent", "actions", "push", "add", "document", "off", "index", "indexOf", "splice", "remove", "debug", "supportsTouch", "browser", "supportsPointerEvent", "stop", "interaction", "interactions", "list", "pointerMoveTolerance", "newValue", "number", "addDocument", "doc", "removeDocument", "Interactable", "constructor", "target", "options", "defaultContext", "scopeEvents", "_actions", "events", "Eventable", "_context", "_win", "_doc", "_scopeEvents", "_rectChecker", "actions", "context", "getWindow", "trySelector", "document", "set", "_defaults", "base", "perAction", "setOnEvents", "actionName", "phases", "is", "func", "onstart", "on", "onmove", "onend", "oninertiastart", "updatePerActionListeners", "prev", "cur", "array", "object", "off", "setPerAction", "defaults", "optionName_", "optionName", "actionOptions", "optionValue", "listeners", "from", "plainObject", "extend", "clone", "enabled", "bool", "getRect", "element", "string", "querySelector", "getElementRect", "rectChecker", "checker", "rect", "width", "right", "left", "height", "bottom", "top", "_backCompatOption", "newValue", "action", "map", "origin", "deltaSource", "inContext", "ownerDocument", "nodeContains", "testIgnoreAllow", "targetNode", "eventTarget", "testIgnore", "ignoreFrom", "testAllow", "allowFrom", "matchesUpTo", "fire", "iEvent", "_onOff", "method", "typeArg", "listenerArg", "addRemove", "normalizeListeners", "type", "browser", "wheelEvent", "listener", "isNonNativeEvent", "types", "actionName_", "methodDict", "methodName", "setting", "unset", "delegatedEvents", "delegated", "i", "length", "selector", "splice", "l", "removeDelegate", "remove", "InteractableSet", "constructor", "scope", "list", "selectorMap", "addListeners", "interactable", "target", "_context", "context", "targetMappings", "is", "string", "id", "targetIndex", "findIndex", "m", "splice", "new", "options", "extend", "actions", "Interactable", "document", "events", "mappingInfo", "addDocument", "_doc", "push", "Object", "defineProperty", "value", "configurable", "fire", "win", "_win", "get", "isSelector", "found", "find", "inContext", "forEachMatch", "node", "callback", "ret", "element", "matchesSelector", "undefined", "install", "scope", "targets", "delegatedEvents", "documents", "eventsMethods", "add", "remove", "addDelegate", "removeDelegate", "delegateListener", "delegateUseCapture", "supportsOptions", "supportsPassive", "document", "createElement", "addEventListener", "capture", "passive", "events", "eventTarget", "type", "listener", "optionalArg", "options", "getOptions", "target", "find", "t", "push", "contains", "targetIndex", "findIndex", "hasOwnProperty", "typeIsEmpty", "typeListeners", "i", "length", "removeEventListener", "splice", "Object", "keys", "selector", "context", "doc", "delegates", "delegate", "d", "listeners", "matchFound", "index", "cur", "fn", "event", "fakeEvent", "FakeEvent", "getEventTargets", "element", "is", "matchesSelector", "nodeContains", "currentTarget", "parentNode", "call", "constructor", "originalEvent", "pExtend", "preventOriginalDefault", "preventDefault", "stopPropagation", "stopImmediatePropagation", "param", "object", "extend", "id", "PointerInfo", "constructor", "id", "pointer", "event", "downTime", "downTarget", "_ProxyValues", "_ProxyMethods", "idCounter", "Interaction", "constructor", "pointerType", "scopeFire", "interactable", "element", "rect", "_rects", "edges", "_scopeFire", "prepared", "name", "axis", "pointers", "downEvent", "downPointer", "_latestPointer", "pointer", "event", "eventTarget", "prevEvent", "pointerIsDown", "pointerWasMoved", "_interacting", "_ending", "_stopped", "_proxy", "simulation", "doMove", "warnOnce", "signalArg", "move", "coords", "start", "newCoords", "prev", "cur", "delta", "velocity", "_id", "that", "key", "Object", "defineProperty", "get", "value", "args", "interaction", "pointerMoveTolerance", "pointerDown", "pointerIndex", "updatePointer", "pointerInfo", "type", "action", "interacting", "length", "options", "enabled", "copyAction", "getRect", "extend", "left", "right", "top", "bottom", "_doPhase", "phase", "pointerMove", "modification", "endResult", "duplicateMove", "page", "x", "y", "client", "dx", "dy", "hypot", "getPointerIndex", "duplicate", "pointerUtils", "setCoordVelocity", "copyCoords", "setZeroCoords", "pointerUp", "curEventTarget", "test", "end", "removePointer", "documentBlur", "endPhaseResult", "stop", "currentAction", "pointerId", "getPointerId", "findIndex", "curPointer", "id", "getPointerInfo", "down", "PointerInfo", "push", "setCoords", "map", "p", "_now", "setCoordDeltas", "downTime", "timeStamp", "downTarget", "pointerExtend", "_updateLatestPointer", "splice", "destroy", "_createPreparedEvent", "preEnd", "InteractEvent", "_fireEvent", "iEvent", "fire", "rectUtils", "addEdges", "deltaSource", "width", "height", "beforeResult", "Date", "now", "preventDefault", "newValue", "test", "options", "is", "bool", "checkAndPreventDefault", "interactable", "scope", "event", "setting", "events", "supportsPassive", "type", "doc", "getWindow", "target", "document", "docOptions", "getDocOptions", "passive", "element", "matchesSelector", "onInteractionEvent", "interaction", "install", "Interactable", "prototype", "interactions", "docEvents", "push", "listener", "list", "nodeContains", "id", "listeners", "reduce", "acc", "eventType", "finder", "methodOrder", "search", "details", "method", "interaction", "simulationResume", "pointerType", "eventType", "eventTarget", "scope", "test", "interactions", "list", "element", "simulation", "allowResume", "parentNode", "mouseOrPen", "pointerId", "firstNonActive", "hasPointerId", "interacting", "hasPointer", "idle", "pointers", "length", "target", "interactable", "options", "gesture", "enabled", "some", "id", "methodNames", "install", "scope", "listeners", "method", "doOnInteractions", "pEventTypes", "browser", "docEvents", "domObjects", "PointerEvent", "type", "down", "listener", "releasePointersOnRemovedEls", "pointerDown", "move", "pointerMove", "up", "pointerUp", "cancel", "push", "event", "interaction", "interactions", "list", "documentBlur", "prevTouchTime", "Interaction", "InteractionBase", "pointerMoveTolerance", "value", "_now", "now", "new", "options", "scopeFire", "name", "arg", "fire", "pointerIsDown", "pointerType", "_interacting", "pointer", "pointers", "documents", "some", "doc", "nodeContains", "downTarget", "removePointer", "usePlugin", "interactablePreventDefault", "getPointerType", "eventTarget", "curEventTarget", "getEventTargets", "matches", "test", "changedTouch", "changedTouches", "pointerId", "getPointerId", "searchDetails", "eventType", "getInteraction", "invalidPointer", "supportsPointerEvent", "i", "length", "timeStamp", "foundInteraction", "finder", "search", "signalArg", "onDocSignal", "eventMethodName", "events", "eventMethod", "isIOS", "passive", "delegatedEvents", "delegateListener", "delegateUseCapture", "eventOptions", "id", "interactable", "stop", "destroy", "splice", "Scope", "constructor", "id", "Math", "floor", "random", "isInitialized", "listenerMaps", "browser", "defaults", "clone", "Eventable", "actions", "map", "phases", "start", "move", "end", "methodDict", "phaselessTypes", "interactStatic", "createInteractStatic", "InteractEvent", "Interactable", "interactables", "InteractableSet", "_win", "document", "window", "documents", "_plugins", "list", "onWindowUnload", "event", "removeDocument", "target", "scope", "InteractableBase", "_defaults", "set", "options", "fire", "interactable", "unset", "index", "indexOf", "splice", "addListeners", "push", "name", "arg", "listener", "init", "initScope", "pluginIsInstalled", "plugin", "usePlugin", "install", "listeners", "before", "len", "length", "reduce", "acc", "pluginIdRoot", "otherId", "addDocument", "doc", "getDocIndex", "getWindow", "extend", "events", "add", "remove", "i", "getDocOptions", "docIndex", "now", "Date", "is", "win", "domObjects", "raf", "interactions", "replace", "scope", "Scope", "interact", "interactStatic", "_global", "globalThis", "window", "init"]
}
